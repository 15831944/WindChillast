/* soapC.cpp
   Generated by gSOAP 2.8.39 for foxwelltech.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.39 2018-10-10 09:11:43 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns1__SearchResource:
		return soap_in_ns1__SearchResource(soap, NULL, NULL, "ns1:SearchResource");
	case SOAP_TYPE_ns1__SearchResourceResponse:
		return soap_in_ns1__SearchResourceResponse(soap, NULL, NULL, "ns1:SearchResourceResponse");
	case SOAP_TYPE_ns1__getDocInfo:
		return soap_in_ns1__getDocInfo(soap, NULL, NULL, "ns1:getDocInfo");
	case SOAP_TYPE_ns1__getDocInfoResponse:
		return soap_in_ns1__getDocInfoResponse(soap, NULL, NULL, "ns1:getDocInfoResponse");
	case SOAP_TYPE_ns1__getDocInfoOfContent:
		return soap_in_ns1__getDocInfoOfContent(soap, NULL, NULL, "ns1:getDocInfoOfContent");
	case SOAP_TYPE_ns1__getDocInfoOfContentResponse:
		return soap_in_ns1__getDocInfoOfContentResponse(soap, NULL, NULL, "ns1:getDocInfoOfContentResponse");
	case SOAP_TYPE_ns1__getBOMOfHsf:
		return soap_in_ns1__getBOMOfHsf(soap, NULL, NULL, "ns1:getBOMOfHsf");
	case SOAP_TYPE_ns1__getBOMOfHsfResponse:
		return soap_in_ns1__getBOMOfHsfResponse(soap, NULL, NULL, "ns1:getBOMOfHsfResponse");
	case SOAP_TYPE_ns1__checkInDoc:
		return soap_in_ns1__checkInDoc(soap, NULL, NULL, "ns1:checkInDoc");
	case SOAP_TYPE_ns1__checkInDocResponse:
		return soap_in_ns1__checkInDocResponse(soap, NULL, NULL, "ns1:checkInDocResponse");
	case SOAP_TYPE_ns1__checkInPbom:
		return soap_in_ns1__checkInPbom(soap, NULL, NULL, "ns1:checkInPbom");
	case SOAP_TYPE_ns1__checkInPbomResponse:
		return soap_in_ns1__checkInPbomResponse(soap, NULL, NULL, "ns1:checkInPbomResponse");
	case SOAP_TYPE_ns1__getBom:
		return soap_in_ns1__getBom(soap, NULL, NULL, "ns1:getBom");
	case SOAP_TYPE_ns1__getBomResponse:
		return soap_in_ns1__getBomResponse(soap, NULL, NULL, "ns1:getBomResponse");
	case SOAP_TYPE_ns1__getPartList:
		return soap_in_ns1__getPartList(soap, NULL, NULL, "ns1:getPartList");
	case SOAP_TYPE_ns1__getPartListResponse:
		return soap_in_ns1__getPartListResponse(soap, NULL, NULL, "ns1:getPartListResponse");
	case SOAP_TYPE_ns1__checkLogin:
		return soap_in_ns1__checkLogin(soap, NULL, NULL, "ns1:checkLogin");
	case SOAP_TYPE_ns1__checkLoginResponse:
		return soap_in_ns1__checkLoginResponse(soap, NULL, NULL, "ns1:checkLoginResponse");
	case SOAP_TYPE_ns1__updateUser:
		return soap_in_ns1__updateUser(soap, NULL, NULL, "ns1:updateUser");
	case SOAP_TYPE_ns1__updateUserResponse:
		return soap_in_ns1__updateUserResponse(soap, NULL, NULL, "ns1:updateUserResponse");
	case SOAP_TYPE_ns1__pendingWork:
		return soap_in_ns1__pendingWork(soap, NULL, NULL, "ns1:pendingWork");
	case SOAP_TYPE_ns1__pendingWorkResponse:
		return soap_in_ns1__pendingWorkResponse(soap, NULL, NULL, "ns1:pendingWorkResponse");
	case SOAP_TYPE_ns1__getordercreatorbynumber:
		return soap_in_ns1__getordercreatorbynumber(soap, NULL, NULL, "ns1:getordercreatorbynumber");
	case SOAP_TYPE_ns1__getordercreatorbynumberResponse:
		return soap_in_ns1__getordercreatorbynumberResponse(soap, NULL, NULL, "ns1:getordercreatorbynumberResponse");
	case SOAP_TYPE_ns1__unCheckOut:
		return soap_in_ns1__unCheckOut(soap, NULL, NULL, "ns1:unCheckOut");
	case SOAP_TYPE_ns1__unCheckOutResponse:
		return soap_in_ns1__unCheckOutResponse(soap, NULL, NULL, "ns1:unCheckOutResponse");
	case SOAP_TYPE_ns1__callProduct:
		return soap_in_ns1__callProduct(soap, NULL, NULL, "ns1:callProduct");
	case SOAP_TYPE_ns1__callProductResponse:
		return soap_in_ns1__callProductResponse(soap, NULL, NULL, "ns1:callProductResponse");
	case SOAP_TYPE_ns1__callCheckIn:
		return soap_in_ns1__callCheckIn(soap, NULL, NULL, "ns1:callCheckIn");
	case SOAP_TYPE_ns1__callCheckInResponse:
		return soap_in_ns1__callCheckInResponse(soap, NULL, NULL, "ns1:callCheckInResponse");
	case SOAP_TYPE_ns1__callCheckOut:
		return soap_in_ns1__callCheckOut(soap, NULL, NULL, "ns1:callCheckOut");
	case SOAP_TYPE_ns1__callCheckOutResponse:
		return soap_in_ns1__callCheckOutResponse(soap, NULL, NULL, "ns1:callCheckOutResponse");
	case SOAP_TYPE_ns1__callCheckUser:
		return soap_in_ns1__callCheckUser(soap, NULL, NULL, "ns1:callCheckUser");
	case SOAP_TYPE_ns1__callCheckUserResponse:
		return soap_in_ns1__callCheckUserResponse(soap, NULL, NULL, "ns1:callCheckUserResponse");
	case SOAP_TYPE_ns1__callSearch:
		return soap_in_ns1__callSearch(soap, NULL, NULL, "ns1:callSearch");
	case SOAP_TYPE_ns1__callSearchResponse:
		return soap_in_ns1__callSearchResponse(soap, NULL, NULL, "ns1:callSearchResponse");
	case SOAP_TYPE_ns1__getFolder:
		return soap_in_ns1__getFolder(soap, NULL, NULL, "ns1:getFolder");
	case SOAP_TYPE_ns1__getFolderResponse:
		return soap_in_ns1__getFolderResponse(soap, NULL, NULL, "ns1:getFolderResponse");
	case SOAP_TYPE_ns1__getZip:
		return soap_in_ns1__getZip(soap, NULL, NULL, "ns1:getZip");
	case SOAP_TYPE_ns1__getZipResponse:
		return soap_in_ns1__getZipResponse(soap, NULL, NULL, "ns1:getZipResponse");
	case SOAP_TYPE_ns1__reviseAndCheckOut:
		return soap_in_ns1__reviseAndCheckOut(soap, NULL, NULL, "ns1:reviseAndCheckOut");
	case SOAP_TYPE_ns1__reviseAndCheckOutResponse:
		return soap_in_ns1__reviseAndCheckOutResponse(soap, NULL, NULL, "ns1:reviseAndCheckOutResponse");
	case SOAP_TYPE_ns1__tipicalCraftSelector:
		return soap_in_ns1__tipicalCraftSelector(soap, NULL, NULL, "ns1:tipicalCraftSelector");
	case SOAP_TYPE_ns1__tipicalCraftSelectorResponse:
		return soap_in_ns1__tipicalCraftSelectorResponse(soap, NULL, NULL, "ns1:tipicalCraftSelectorResponse");
	case SOAP_TYPE_ns1__getorderbynumber:
		return soap_in_ns1__getorderbynumber(soap, NULL, NULL, "ns1:getorderbynumber");
	case SOAP_TYPE_ns1__getorderbynumberResponse:
		return soap_in_ns1__getorderbynumberResponse(soap, NULL, NULL, "ns1:getorderbynumberResponse");
	case SOAP_TYPE_ns1__lingZuJianSelector:
		return soap_in_ns1__lingZuJianSelector(soap, NULL, NULL, "ns1:lingZuJianSelector");
	case SOAP_TYPE_ns1__lingZuJianSelectorResponse:
		return soap_in_ns1__lingZuJianSelectorResponse(soap, NULL, NULL, "ns1:lingZuJianSelectorResponse");
	case SOAP_TYPE_ns1__sheBeiSelector:
		return soap_in_ns1__sheBeiSelector(soap, NULL, NULL, "ns1:sheBeiSelector");
	case SOAP_TYPE_ns1__sheBeiSelectorResponse:
		return soap_in_ns1__sheBeiSelectorResponse(soap, NULL, NULL, "ns1:sheBeiSelectorResponse");
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumber:
		return soap_in_ns1__loadAssemblePartsByPartNumber(soap, NULL, NULL, "ns1:loadAssemblePartsByPartNumber");
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse:
		return soap_in_ns1__loadAssemblePartsByPartNumberResponse(soap, NULL, NULL, "ns1:loadAssemblePartsByPartNumberResponse");
	case SOAP_TYPE_ns1__gongZhuangSelector:
		return soap_in_ns1__gongZhuangSelector(soap, NULL, NULL, "ns1:gongZhuangSelector");
	case SOAP_TYPE_ns1__gongZhuangSelectorResponse:
		return soap_in_ns1__gongZhuangSelectorResponse(soap, NULL, NULL, "ns1:gongZhuangSelectorResponse");
	case SOAP_TYPE_ns1__gongliangjiajuSelector:
		return soap_in_ns1__gongliangjiajuSelector(soap, NULL, NULL, "ns1:gongliangjiajuSelector");
	case SOAP_TYPE_ns1__gongliangjiajuSelectorResponse:
		return soap_in_ns1__gongliangjiajuSelectorResponse(soap, NULL, NULL, "ns1:gongliangjiajuSelectorResponse");
	case SOAP_TYPE_ns1__fuZhuJianSelector:
		return soap_in_ns1__fuZhuJianSelector(soap, NULL, NULL, "ns1:fuZhuJianSelector");
	case SOAP_TYPE_ns1__fuZhuJianSelectorResponse:
		return soap_in_ns1__fuZhuJianSelectorResponse(soap, NULL, NULL, "ns1:fuZhuJianSelectorResponse");
	case SOAP_TYPE_ns1__savechangeordertowc:
		return soap_in_ns1__savechangeordertowc(soap, NULL, NULL, "ns1:savechangeordertowc");
	case SOAP_TYPE_ns1__savechangeordertowcResponse:
		return soap_in_ns1__savechangeordertowcResponse(soap, NULL, NULL, "ns1:savechangeordertowcResponse");
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber:
		return soap_in_ns1__getPbomOriginalItemByPartNumber(soap, NULL, NULL, "ns1:getPbomOriginalItemByPartNumber");
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse:
		return soap_in_ns1__getPbomOriginalItemByPartNumberResponse(soap, NULL, NULL, "ns1:getPbomOriginalItemByPartNumberResponse");
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumber:
		return soap_in_ns1__getPbomEndPartByPartNumber(soap, NULL, NULL, "ns1:getPbomEndPartByPartNumber");
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse:
		return soap_in_ns1__getPbomEndPartByPartNumberResponse(soap, NULL, NULL, "ns1:getPbomEndPartByPartNumberResponse");
	case SOAP_TYPE_ns1__getorderbyoid:
		return soap_in_ns1__getorderbyoid(soap, NULL, NULL, "ns1:getorderbyoid");
	case SOAP_TYPE_ns1__getorderbyoidResponse:
		return soap_in_ns1__getorderbyoidResponse(soap, NULL, NULL, "ns1:getorderbyoidResponse");
	case SOAP_TYPE_ns1__saveordertowc:
		return soap_in_ns1__saveordertowc(soap, NULL, NULL, "ns1:saveordertowc");
	case SOAP_TYPE_ns1__saveordertowcResponse:
		return soap_in_ns1__saveordertowcResponse(soap, NULL, NULL, "ns1:saveordertowcResponse");
	case SOAP_TYPE_ns1__getPbomLinkByPartNumber:
		return soap_in_ns1__getPbomLinkByPartNumber(soap, NULL, NULL, "ns1:getPbomLinkByPartNumber");
	case SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse:
		return soap_in_ns1__getPbomLinkByPartNumberResponse(soap, NULL, NULL, "ns1:getPbomLinkByPartNumberResponse");
	case SOAP_TYPE_ns1__ping:
		return soap_in_ns1__ping(soap, NULL, NULL, "ns1:ping");
	case SOAP_TYPE_ns1__pingResponse:
		return soap_in_ns1__pingResponse(soap, NULL, NULL, "ns1:pingResponse");
	case SOAP_TYPE_ns1__jmsexample:
		return soap_in_ns1__jmsexample(soap, NULL, NULL, "ns1:jmsexample");
	case SOAP_TYPE_ns1__jmsexampleResponse:
		return soap_in_ns1__jmsexampleResponse(soap, NULL, NULL, "ns1:jmsexampleResponse");
	case SOAP_TYPE_ns1__GetWSDL:
		return soap_in_ns1__GetWSDL(soap, NULL, NULL, "ns1:GetWSDL");
	case SOAP_TYPE_ns1__GetWSDLResponse:
		return soap_in_ns1__GetWSDLResponse(soap, NULL, NULL, "ns1:GetWSDLResponse");
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPC:
		return soap_in_ns1__ExecuteSoapJmsRPC(soap, NULL, NULL, "ns1:ExecuteSoapJmsRPC");
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse:
		return soap_in_ns1__ExecuteSoapJmsRPCResponse(soap, NULL, NULL, "ns1:ExecuteSoapJmsRPCResponse");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchResource"))
		{	*type = SOAP_TYPE_ns1__SearchResource;
			return soap_in_ns1__SearchResource(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SearchResourceResponse"))
		{	*type = SOAP_TYPE_ns1__SearchResourceResponse;
			return soap_in_ns1__SearchResourceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDocInfo"))
		{	*type = SOAP_TYPE_ns1__getDocInfo;
			return soap_in_ns1__getDocInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDocInfoResponse"))
		{	*type = SOAP_TYPE_ns1__getDocInfoResponse;
			return soap_in_ns1__getDocInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDocInfoOfContent"))
		{	*type = SOAP_TYPE_ns1__getDocInfoOfContent;
			return soap_in_ns1__getDocInfoOfContent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDocInfoOfContentResponse"))
		{	*type = SOAP_TYPE_ns1__getDocInfoOfContentResponse;
			return soap_in_ns1__getDocInfoOfContentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBOMOfHsf"))
		{	*type = SOAP_TYPE_ns1__getBOMOfHsf;
			return soap_in_ns1__getBOMOfHsf(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBOMOfHsfResponse"))
		{	*type = SOAP_TYPE_ns1__getBOMOfHsfResponse;
			return soap_in_ns1__getBOMOfHsfResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkInDoc"))
		{	*type = SOAP_TYPE_ns1__checkInDoc;
			return soap_in_ns1__checkInDoc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkInDocResponse"))
		{	*type = SOAP_TYPE_ns1__checkInDocResponse;
			return soap_in_ns1__checkInDocResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkInPbom"))
		{	*type = SOAP_TYPE_ns1__checkInPbom;
			return soap_in_ns1__checkInPbom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkInPbomResponse"))
		{	*type = SOAP_TYPE_ns1__checkInPbomResponse;
			return soap_in_ns1__checkInPbomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBom"))
		{	*type = SOAP_TYPE_ns1__getBom;
			return soap_in_ns1__getBom(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getBomResponse"))
		{	*type = SOAP_TYPE_ns1__getBomResponse;
			return soap_in_ns1__getBomResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPartList"))
		{	*type = SOAP_TYPE_ns1__getPartList;
			return soap_in_ns1__getPartList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPartListResponse"))
		{	*type = SOAP_TYPE_ns1__getPartListResponse;
			return soap_in_ns1__getPartListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkLogin"))
		{	*type = SOAP_TYPE_ns1__checkLogin;
			return soap_in_ns1__checkLogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:checkLoginResponse"))
		{	*type = SOAP_TYPE_ns1__checkLoginResponse;
			return soap_in_ns1__checkLoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateUser"))
		{	*type = SOAP_TYPE_ns1__updateUser;
			return soap_in_ns1__updateUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateUserResponse"))
		{	*type = SOAP_TYPE_ns1__updateUserResponse;
			return soap_in_ns1__updateUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:pendingWork"))
		{	*type = SOAP_TYPE_ns1__pendingWork;
			return soap_in_ns1__pendingWork(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:pendingWorkResponse"))
		{	*type = SOAP_TYPE_ns1__pendingWorkResponse;
			return soap_in_ns1__pendingWorkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getordercreatorbynumber"))
		{	*type = SOAP_TYPE_ns1__getordercreatorbynumber;
			return soap_in_ns1__getordercreatorbynumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getordercreatorbynumberResponse"))
		{	*type = SOAP_TYPE_ns1__getordercreatorbynumberResponse;
			return soap_in_ns1__getordercreatorbynumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unCheckOut"))
		{	*type = SOAP_TYPE_ns1__unCheckOut;
			return soap_in_ns1__unCheckOut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unCheckOutResponse"))
		{	*type = SOAP_TYPE_ns1__unCheckOutResponse;
			return soap_in_ns1__unCheckOutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callProduct"))
		{	*type = SOAP_TYPE_ns1__callProduct;
			return soap_in_ns1__callProduct(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callProductResponse"))
		{	*type = SOAP_TYPE_ns1__callProductResponse;
			return soap_in_ns1__callProductResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callCheckIn"))
		{	*type = SOAP_TYPE_ns1__callCheckIn;
			return soap_in_ns1__callCheckIn(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callCheckInResponse"))
		{	*type = SOAP_TYPE_ns1__callCheckInResponse;
			return soap_in_ns1__callCheckInResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callCheckOut"))
		{	*type = SOAP_TYPE_ns1__callCheckOut;
			return soap_in_ns1__callCheckOut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callCheckOutResponse"))
		{	*type = SOAP_TYPE_ns1__callCheckOutResponse;
			return soap_in_ns1__callCheckOutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callCheckUser"))
		{	*type = SOAP_TYPE_ns1__callCheckUser;
			return soap_in_ns1__callCheckUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callCheckUserResponse"))
		{	*type = SOAP_TYPE_ns1__callCheckUserResponse;
			return soap_in_ns1__callCheckUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callSearch"))
		{	*type = SOAP_TYPE_ns1__callSearch;
			return soap_in_ns1__callSearch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:callSearchResponse"))
		{	*type = SOAP_TYPE_ns1__callSearchResponse;
			return soap_in_ns1__callSearchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolder"))
		{	*type = SOAP_TYPE_ns1__getFolder;
			return soap_in_ns1__getFolder(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getFolderResponse"))
		{	*type = SOAP_TYPE_ns1__getFolderResponse;
			return soap_in_ns1__getFolderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getZip"))
		{	*type = SOAP_TYPE_ns1__getZip;
			return soap_in_ns1__getZip(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getZipResponse"))
		{	*type = SOAP_TYPE_ns1__getZipResponse;
			return soap_in_ns1__getZipResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:reviseAndCheckOut"))
		{	*type = SOAP_TYPE_ns1__reviseAndCheckOut;
			return soap_in_ns1__reviseAndCheckOut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:reviseAndCheckOutResponse"))
		{	*type = SOAP_TYPE_ns1__reviseAndCheckOutResponse;
			return soap_in_ns1__reviseAndCheckOutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:tipicalCraftSelector"))
		{	*type = SOAP_TYPE_ns1__tipicalCraftSelector;
			return soap_in_ns1__tipicalCraftSelector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:tipicalCraftSelectorResponse"))
		{	*type = SOAP_TYPE_ns1__tipicalCraftSelectorResponse;
			return soap_in_ns1__tipicalCraftSelectorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getorderbynumber"))
		{	*type = SOAP_TYPE_ns1__getorderbynumber;
			return soap_in_ns1__getorderbynumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getorderbynumberResponse"))
		{	*type = SOAP_TYPE_ns1__getorderbynumberResponse;
			return soap_in_ns1__getorderbynumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lingZuJianSelector"))
		{	*type = SOAP_TYPE_ns1__lingZuJianSelector;
			return soap_in_ns1__lingZuJianSelector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:lingZuJianSelectorResponse"))
		{	*type = SOAP_TYPE_ns1__lingZuJianSelectorResponse;
			return soap_in_ns1__lingZuJianSelectorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sheBeiSelector"))
		{	*type = SOAP_TYPE_ns1__sheBeiSelector;
			return soap_in_ns1__sheBeiSelector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sheBeiSelectorResponse"))
		{	*type = SOAP_TYPE_ns1__sheBeiSelectorResponse;
			return soap_in_ns1__sheBeiSelectorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadAssemblePartsByPartNumber"))
		{	*type = SOAP_TYPE_ns1__loadAssemblePartsByPartNumber;
			return soap_in_ns1__loadAssemblePartsByPartNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:loadAssemblePartsByPartNumberResponse"))
		{	*type = SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse;
			return soap_in_ns1__loadAssemblePartsByPartNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gongZhuangSelector"))
		{	*type = SOAP_TYPE_ns1__gongZhuangSelector;
			return soap_in_ns1__gongZhuangSelector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gongZhuangSelectorResponse"))
		{	*type = SOAP_TYPE_ns1__gongZhuangSelectorResponse;
			return soap_in_ns1__gongZhuangSelectorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gongliangjiajuSelector"))
		{	*type = SOAP_TYPE_ns1__gongliangjiajuSelector;
			return soap_in_ns1__gongliangjiajuSelector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:gongliangjiajuSelectorResponse"))
		{	*type = SOAP_TYPE_ns1__gongliangjiajuSelectorResponse;
			return soap_in_ns1__gongliangjiajuSelectorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fuZhuJianSelector"))
		{	*type = SOAP_TYPE_ns1__fuZhuJianSelector;
			return soap_in_ns1__fuZhuJianSelector(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fuZhuJianSelectorResponse"))
		{	*type = SOAP_TYPE_ns1__fuZhuJianSelectorResponse;
			return soap_in_ns1__fuZhuJianSelectorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:savechangeordertowc"))
		{	*type = SOAP_TYPE_ns1__savechangeordertowc;
			return soap_in_ns1__savechangeordertowc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:savechangeordertowcResponse"))
		{	*type = SOAP_TYPE_ns1__savechangeordertowcResponse;
			return soap_in_ns1__savechangeordertowcResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPbomOriginalItemByPartNumber"))
		{	*type = SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber;
			return soap_in_ns1__getPbomOriginalItemByPartNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPbomOriginalItemByPartNumberResponse"))
		{	*type = SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse;
			return soap_in_ns1__getPbomOriginalItemByPartNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPbomEndPartByPartNumber"))
		{	*type = SOAP_TYPE_ns1__getPbomEndPartByPartNumber;
			return soap_in_ns1__getPbomEndPartByPartNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPbomEndPartByPartNumberResponse"))
		{	*type = SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse;
			return soap_in_ns1__getPbomEndPartByPartNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getorderbyoid"))
		{	*type = SOAP_TYPE_ns1__getorderbyoid;
			return soap_in_ns1__getorderbyoid(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getorderbyoidResponse"))
		{	*type = SOAP_TYPE_ns1__getorderbyoidResponse;
			return soap_in_ns1__getorderbyoidResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveordertowc"))
		{	*type = SOAP_TYPE_ns1__saveordertowc;
			return soap_in_ns1__saveordertowc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:saveordertowcResponse"))
		{	*type = SOAP_TYPE_ns1__saveordertowcResponse;
			return soap_in_ns1__saveordertowcResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPbomLinkByPartNumber"))
		{	*type = SOAP_TYPE_ns1__getPbomLinkByPartNumber;
			return soap_in_ns1__getPbomLinkByPartNumber(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPbomLinkByPartNumberResponse"))
		{	*type = SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse;
			return soap_in_ns1__getPbomLinkByPartNumberResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ping"))
		{	*type = SOAP_TYPE_ns1__ping;
			return soap_in_ns1__ping(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:pingResponse"))
		{	*type = SOAP_TYPE_ns1__pingResponse;
			return soap_in_ns1__pingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jmsexample"))
		{	*type = SOAP_TYPE_ns1__jmsexample;
			return soap_in_ns1__jmsexample(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:jmsexampleResponse"))
		{	*type = SOAP_TYPE_ns1__jmsexampleResponse;
			return soap_in_ns1__jmsexampleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWSDL"))
		{	*type = SOAP_TYPE_ns1__GetWSDL;
			return soap_in_ns1__GetWSDL(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetWSDLResponse"))
		{	*type = SOAP_TYPE_ns1__GetWSDLResponse;
			return soap_in_ns1__GetWSDLResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSoapJmsRPC"))
		{	*type = SOAP_TYPE_ns1__ExecuteSoapJmsRPC;
			return soap_in_ns1__ExecuteSoapJmsRPC(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteSoapJmsRPCResponse"))
		{	*type = SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse;
			return soap_in_ns1__ExecuteSoapJmsRPCResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns1__SearchResource:
		return soap_out_ns1__SearchResource(soap, tag, id, (const struct ns1__SearchResource *)ptr, "ns1:SearchResource");
	case SOAP_TYPE_ns1__SearchResourceResponse:
		return soap_out_ns1__SearchResourceResponse(soap, tag, id, (const struct ns1__SearchResourceResponse *)ptr, "ns1:SearchResourceResponse");
	case SOAP_TYPE_ns1__getDocInfo:
		return soap_out_ns1__getDocInfo(soap, tag, id, (const struct ns1__getDocInfo *)ptr, "ns1:getDocInfo");
	case SOAP_TYPE_ns1__getDocInfoResponse:
		return soap_out_ns1__getDocInfoResponse(soap, tag, id, (const struct ns1__getDocInfoResponse *)ptr, "ns1:getDocInfoResponse");
	case SOAP_TYPE_ns1__getDocInfoOfContent:
		return soap_out_ns1__getDocInfoOfContent(soap, tag, id, (const struct ns1__getDocInfoOfContent *)ptr, "ns1:getDocInfoOfContent");
	case SOAP_TYPE_ns1__getDocInfoOfContentResponse:
		return soap_out_ns1__getDocInfoOfContentResponse(soap, tag, id, (const struct ns1__getDocInfoOfContentResponse *)ptr, "ns1:getDocInfoOfContentResponse");
	case SOAP_TYPE_ns1__getBOMOfHsf:
		return soap_out_ns1__getBOMOfHsf(soap, tag, id, (const struct ns1__getBOMOfHsf *)ptr, "ns1:getBOMOfHsf");
	case SOAP_TYPE_ns1__getBOMOfHsfResponse:
		return soap_out_ns1__getBOMOfHsfResponse(soap, tag, id, (const struct ns1__getBOMOfHsfResponse *)ptr, "ns1:getBOMOfHsfResponse");
	case SOAP_TYPE_ns1__checkInDoc:
		return soap_out_ns1__checkInDoc(soap, tag, id, (const struct ns1__checkInDoc *)ptr, "ns1:checkInDoc");
	case SOAP_TYPE_ns1__checkInDocResponse:
		return soap_out_ns1__checkInDocResponse(soap, tag, id, (const struct ns1__checkInDocResponse *)ptr, "ns1:checkInDocResponse");
	case SOAP_TYPE_ns1__checkInPbom:
		return soap_out_ns1__checkInPbom(soap, tag, id, (const struct ns1__checkInPbom *)ptr, "ns1:checkInPbom");
	case SOAP_TYPE_ns1__checkInPbomResponse:
		return soap_out_ns1__checkInPbomResponse(soap, tag, id, (const struct ns1__checkInPbomResponse *)ptr, "ns1:checkInPbomResponse");
	case SOAP_TYPE_ns1__getBom:
		return soap_out_ns1__getBom(soap, tag, id, (const struct ns1__getBom *)ptr, "ns1:getBom");
	case SOAP_TYPE_ns1__getBomResponse:
		return soap_out_ns1__getBomResponse(soap, tag, id, (const struct ns1__getBomResponse *)ptr, "ns1:getBomResponse");
	case SOAP_TYPE_ns1__getPartList:
		return soap_out_ns1__getPartList(soap, tag, id, (const struct ns1__getPartList *)ptr, "ns1:getPartList");
	case SOAP_TYPE_ns1__getPartListResponse:
		return soap_out_ns1__getPartListResponse(soap, tag, id, (const struct ns1__getPartListResponse *)ptr, "ns1:getPartListResponse");
	case SOAP_TYPE_ns1__checkLogin:
		return soap_out_ns1__checkLogin(soap, tag, id, (const struct ns1__checkLogin *)ptr, "ns1:checkLogin");
	case SOAP_TYPE_ns1__checkLoginResponse:
		return soap_out_ns1__checkLoginResponse(soap, tag, id, (const struct ns1__checkLoginResponse *)ptr, "ns1:checkLoginResponse");
	case SOAP_TYPE_ns1__updateUser:
		return soap_out_ns1__updateUser(soap, tag, id, (const struct ns1__updateUser *)ptr, "ns1:updateUser");
	case SOAP_TYPE_ns1__updateUserResponse:
		return soap_out_ns1__updateUserResponse(soap, tag, id, (const struct ns1__updateUserResponse *)ptr, "ns1:updateUserResponse");
	case SOAP_TYPE_ns1__pendingWork:
		return soap_out_ns1__pendingWork(soap, tag, id, (const struct ns1__pendingWork *)ptr, "ns1:pendingWork");
	case SOAP_TYPE_ns1__pendingWorkResponse:
		return soap_out_ns1__pendingWorkResponse(soap, tag, id, (const struct ns1__pendingWorkResponse *)ptr, "ns1:pendingWorkResponse");
	case SOAP_TYPE_ns1__getordercreatorbynumber:
		return soap_out_ns1__getordercreatorbynumber(soap, tag, id, (const struct ns1__getordercreatorbynumber *)ptr, "ns1:getordercreatorbynumber");
	case SOAP_TYPE_ns1__getordercreatorbynumberResponse:
		return soap_out_ns1__getordercreatorbynumberResponse(soap, tag, id, (const struct ns1__getordercreatorbynumberResponse *)ptr, "ns1:getordercreatorbynumberResponse");
	case SOAP_TYPE_ns1__unCheckOut:
		return soap_out_ns1__unCheckOut(soap, tag, id, (const struct ns1__unCheckOut *)ptr, "ns1:unCheckOut");
	case SOAP_TYPE_ns1__unCheckOutResponse:
		return soap_out_ns1__unCheckOutResponse(soap, tag, id, (const struct ns1__unCheckOutResponse *)ptr, "ns1:unCheckOutResponse");
	case SOAP_TYPE_ns1__callProduct:
		return soap_out_ns1__callProduct(soap, tag, id, (const struct ns1__callProduct *)ptr, "ns1:callProduct");
	case SOAP_TYPE_ns1__callProductResponse:
		return soap_out_ns1__callProductResponse(soap, tag, id, (const struct ns1__callProductResponse *)ptr, "ns1:callProductResponse");
	case SOAP_TYPE_ns1__callCheckIn:
		return soap_out_ns1__callCheckIn(soap, tag, id, (const struct ns1__callCheckIn *)ptr, "ns1:callCheckIn");
	case SOAP_TYPE_ns1__callCheckInResponse:
		return soap_out_ns1__callCheckInResponse(soap, tag, id, (const struct ns1__callCheckInResponse *)ptr, "ns1:callCheckInResponse");
	case SOAP_TYPE_ns1__callCheckOut:
		return soap_out_ns1__callCheckOut(soap, tag, id, (const struct ns1__callCheckOut *)ptr, "ns1:callCheckOut");
	case SOAP_TYPE_ns1__callCheckOutResponse:
		return soap_out_ns1__callCheckOutResponse(soap, tag, id, (const struct ns1__callCheckOutResponse *)ptr, "ns1:callCheckOutResponse");
	case SOAP_TYPE_ns1__callCheckUser:
		return soap_out_ns1__callCheckUser(soap, tag, id, (const struct ns1__callCheckUser *)ptr, "ns1:callCheckUser");
	case SOAP_TYPE_ns1__callCheckUserResponse:
		return soap_out_ns1__callCheckUserResponse(soap, tag, id, (const struct ns1__callCheckUserResponse *)ptr, "ns1:callCheckUserResponse");
	case SOAP_TYPE_ns1__callSearch:
		return soap_out_ns1__callSearch(soap, tag, id, (const struct ns1__callSearch *)ptr, "ns1:callSearch");
	case SOAP_TYPE_ns1__callSearchResponse:
		return soap_out_ns1__callSearchResponse(soap, tag, id, (const struct ns1__callSearchResponse *)ptr, "ns1:callSearchResponse");
	case SOAP_TYPE_ns1__getFolder:
		return soap_out_ns1__getFolder(soap, tag, id, (const struct ns1__getFolder *)ptr, "ns1:getFolder");
	case SOAP_TYPE_ns1__getFolderResponse:
		return soap_out_ns1__getFolderResponse(soap, tag, id, (const struct ns1__getFolderResponse *)ptr, "ns1:getFolderResponse");
	case SOAP_TYPE_ns1__getZip:
		return soap_out_ns1__getZip(soap, tag, id, (const struct ns1__getZip *)ptr, "ns1:getZip");
	case SOAP_TYPE_ns1__getZipResponse:
		return soap_out_ns1__getZipResponse(soap, tag, id, (const struct ns1__getZipResponse *)ptr, "ns1:getZipResponse");
	case SOAP_TYPE_ns1__reviseAndCheckOut:
		return soap_out_ns1__reviseAndCheckOut(soap, tag, id, (const struct ns1__reviseAndCheckOut *)ptr, "ns1:reviseAndCheckOut");
	case SOAP_TYPE_ns1__reviseAndCheckOutResponse:
		return soap_out_ns1__reviseAndCheckOutResponse(soap, tag, id, (const struct ns1__reviseAndCheckOutResponse *)ptr, "ns1:reviseAndCheckOutResponse");
	case SOAP_TYPE_ns1__tipicalCraftSelector:
		return soap_out_ns1__tipicalCraftSelector(soap, tag, id, (const struct ns1__tipicalCraftSelector *)ptr, "ns1:tipicalCraftSelector");
	case SOAP_TYPE_ns1__tipicalCraftSelectorResponse:
		return soap_out_ns1__tipicalCraftSelectorResponse(soap, tag, id, (const struct ns1__tipicalCraftSelectorResponse *)ptr, "ns1:tipicalCraftSelectorResponse");
	case SOAP_TYPE_ns1__getorderbynumber:
		return soap_out_ns1__getorderbynumber(soap, tag, id, (const struct ns1__getorderbynumber *)ptr, "ns1:getorderbynumber");
	case SOAP_TYPE_ns1__getorderbynumberResponse:
		return soap_out_ns1__getorderbynumberResponse(soap, tag, id, (const struct ns1__getorderbynumberResponse *)ptr, "ns1:getorderbynumberResponse");
	case SOAP_TYPE_ns1__lingZuJianSelector:
		return soap_out_ns1__lingZuJianSelector(soap, tag, id, (const struct ns1__lingZuJianSelector *)ptr, "ns1:lingZuJianSelector");
	case SOAP_TYPE_ns1__lingZuJianSelectorResponse:
		return soap_out_ns1__lingZuJianSelectorResponse(soap, tag, id, (const struct ns1__lingZuJianSelectorResponse *)ptr, "ns1:lingZuJianSelectorResponse");
	case SOAP_TYPE_ns1__sheBeiSelector:
		return soap_out_ns1__sheBeiSelector(soap, tag, id, (const struct ns1__sheBeiSelector *)ptr, "ns1:sheBeiSelector");
	case SOAP_TYPE_ns1__sheBeiSelectorResponse:
		return soap_out_ns1__sheBeiSelectorResponse(soap, tag, id, (const struct ns1__sheBeiSelectorResponse *)ptr, "ns1:sheBeiSelectorResponse");
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumber:
		return soap_out_ns1__loadAssemblePartsByPartNumber(soap, tag, id, (const struct ns1__loadAssemblePartsByPartNumber *)ptr, "ns1:loadAssemblePartsByPartNumber");
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse:
		return soap_out_ns1__loadAssemblePartsByPartNumberResponse(soap, tag, id, (const struct ns1__loadAssemblePartsByPartNumberResponse *)ptr, "ns1:loadAssemblePartsByPartNumberResponse");
	case SOAP_TYPE_ns1__gongZhuangSelector:
		return soap_out_ns1__gongZhuangSelector(soap, tag, id, (const struct ns1__gongZhuangSelector *)ptr, "ns1:gongZhuangSelector");
	case SOAP_TYPE_ns1__gongZhuangSelectorResponse:
		return soap_out_ns1__gongZhuangSelectorResponse(soap, tag, id, (const struct ns1__gongZhuangSelectorResponse *)ptr, "ns1:gongZhuangSelectorResponse");
	case SOAP_TYPE_ns1__gongliangjiajuSelector:
		return soap_out_ns1__gongliangjiajuSelector(soap, tag, id, (const struct ns1__gongliangjiajuSelector *)ptr, "ns1:gongliangjiajuSelector");
	case SOAP_TYPE_ns1__gongliangjiajuSelectorResponse:
		return soap_out_ns1__gongliangjiajuSelectorResponse(soap, tag, id, (const struct ns1__gongliangjiajuSelectorResponse *)ptr, "ns1:gongliangjiajuSelectorResponse");
	case SOAP_TYPE_ns1__fuZhuJianSelector:
		return soap_out_ns1__fuZhuJianSelector(soap, tag, id, (const struct ns1__fuZhuJianSelector *)ptr, "ns1:fuZhuJianSelector");
	case SOAP_TYPE_ns1__fuZhuJianSelectorResponse:
		return soap_out_ns1__fuZhuJianSelectorResponse(soap, tag, id, (const struct ns1__fuZhuJianSelectorResponse *)ptr, "ns1:fuZhuJianSelectorResponse");
	case SOAP_TYPE_ns1__savechangeordertowc:
		return soap_out_ns1__savechangeordertowc(soap, tag, id, (const struct ns1__savechangeordertowc *)ptr, "ns1:savechangeordertowc");
	case SOAP_TYPE_ns1__savechangeordertowcResponse:
		return soap_out_ns1__savechangeordertowcResponse(soap, tag, id, (const struct ns1__savechangeordertowcResponse *)ptr, "ns1:savechangeordertowcResponse");
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber:
		return soap_out_ns1__getPbomOriginalItemByPartNumber(soap, tag, id, (const struct ns1__getPbomOriginalItemByPartNumber *)ptr, "ns1:getPbomOriginalItemByPartNumber");
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse:
		return soap_out_ns1__getPbomOriginalItemByPartNumberResponse(soap, tag, id, (const struct ns1__getPbomOriginalItemByPartNumberResponse *)ptr, "ns1:getPbomOriginalItemByPartNumberResponse");
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumber:
		return soap_out_ns1__getPbomEndPartByPartNumber(soap, tag, id, (const struct ns1__getPbomEndPartByPartNumber *)ptr, "ns1:getPbomEndPartByPartNumber");
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse:
		return soap_out_ns1__getPbomEndPartByPartNumberResponse(soap, tag, id, (const struct ns1__getPbomEndPartByPartNumberResponse *)ptr, "ns1:getPbomEndPartByPartNumberResponse");
	case SOAP_TYPE_ns1__getorderbyoid:
		return soap_out_ns1__getorderbyoid(soap, tag, id, (const struct ns1__getorderbyoid *)ptr, "ns1:getorderbyoid");
	case SOAP_TYPE_ns1__getorderbyoidResponse:
		return soap_out_ns1__getorderbyoidResponse(soap, tag, id, (const struct ns1__getorderbyoidResponse *)ptr, "ns1:getorderbyoidResponse");
	case SOAP_TYPE_ns1__saveordertowc:
		return soap_out_ns1__saveordertowc(soap, tag, id, (const struct ns1__saveordertowc *)ptr, "ns1:saveordertowc");
	case SOAP_TYPE_ns1__saveordertowcResponse:
		return soap_out_ns1__saveordertowcResponse(soap, tag, id, (const struct ns1__saveordertowcResponse *)ptr, "ns1:saveordertowcResponse");
	case SOAP_TYPE_ns1__getPbomLinkByPartNumber:
		return soap_out_ns1__getPbomLinkByPartNumber(soap, tag, id, (const struct ns1__getPbomLinkByPartNumber *)ptr, "ns1:getPbomLinkByPartNumber");
	case SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse:
		return soap_out_ns1__getPbomLinkByPartNumberResponse(soap, tag, id, (const struct ns1__getPbomLinkByPartNumberResponse *)ptr, "ns1:getPbomLinkByPartNumberResponse");
	case SOAP_TYPE_ns1__ping:
		return soap_out_ns1__ping(soap, tag, id, (const struct ns1__ping *)ptr, "ns1:ping");
	case SOAP_TYPE_ns1__pingResponse:
		return soap_out_ns1__pingResponse(soap, tag, id, (const struct ns1__pingResponse *)ptr, "ns1:pingResponse");
	case SOAP_TYPE_ns1__jmsexample:
		return soap_out_ns1__jmsexample(soap, tag, id, (const struct ns1__jmsexample *)ptr, "ns1:jmsexample");
	case SOAP_TYPE_ns1__jmsexampleResponse:
		return soap_out_ns1__jmsexampleResponse(soap, tag, id, (const struct ns1__jmsexampleResponse *)ptr, "ns1:jmsexampleResponse");
	case SOAP_TYPE_ns1__GetWSDL:
		return soap_out_ns1__GetWSDL(soap, tag, id, (const struct ns1__GetWSDL *)ptr, "ns1:GetWSDL");
	case SOAP_TYPE_ns1__GetWSDLResponse:
		return soap_out_ns1__GetWSDLResponse(soap, tag, id, (const struct ns1__GetWSDLResponse *)ptr, "ns1:GetWSDLResponse");
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPC:
		return soap_out_ns1__ExecuteSoapJmsRPC(soap, tag, id, (const struct ns1__ExecuteSoapJmsRPC *)ptr, "ns1:ExecuteSoapJmsRPC");
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse:
		return soap_out_ns1__ExecuteSoapJmsRPCResponse(soap, tag, id, (const struct ns1__ExecuteSoapJmsRPCResponse *)ptr, "ns1:ExecuteSoapJmsRPCResponse");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__SearchResource:
		soap_serialize_ns1__SearchResource(soap, (const struct ns1__SearchResource *)ptr);
		break;
	case SOAP_TYPE_ns1__SearchResourceResponse:
		soap_serialize_ns1__SearchResourceResponse(soap, (const struct ns1__SearchResourceResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDocInfo:
		soap_serialize_ns1__getDocInfo(soap, (const struct ns1__getDocInfo *)ptr);
		break;
	case SOAP_TYPE_ns1__getDocInfoResponse:
		soap_serialize_ns1__getDocInfoResponse(soap, (const struct ns1__getDocInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDocInfoOfContent:
		soap_serialize_ns1__getDocInfoOfContent(soap, (const struct ns1__getDocInfoOfContent *)ptr);
		break;
	case SOAP_TYPE_ns1__getDocInfoOfContentResponse:
		soap_serialize_ns1__getDocInfoOfContentResponse(soap, (const struct ns1__getDocInfoOfContentResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getBOMOfHsf:
		soap_serialize_ns1__getBOMOfHsf(soap, (const struct ns1__getBOMOfHsf *)ptr);
		break;
	case SOAP_TYPE_ns1__getBOMOfHsfResponse:
		soap_serialize_ns1__getBOMOfHsfResponse(soap, (const struct ns1__getBOMOfHsfResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__checkInDoc:
		soap_serialize_ns1__checkInDoc(soap, (const struct ns1__checkInDoc *)ptr);
		break;
	case SOAP_TYPE_ns1__checkInDocResponse:
		soap_serialize_ns1__checkInDocResponse(soap, (const struct ns1__checkInDocResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__checkInPbom:
		soap_serialize_ns1__checkInPbom(soap, (const struct ns1__checkInPbom *)ptr);
		break;
	case SOAP_TYPE_ns1__checkInPbomResponse:
		soap_serialize_ns1__checkInPbomResponse(soap, (const struct ns1__checkInPbomResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getBom:
		soap_serialize_ns1__getBom(soap, (const struct ns1__getBom *)ptr);
		break;
	case SOAP_TYPE_ns1__getBomResponse:
		soap_serialize_ns1__getBomResponse(soap, (const struct ns1__getBomResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getPartList:
		soap_serialize_ns1__getPartList(soap, (const struct ns1__getPartList *)ptr);
		break;
	case SOAP_TYPE_ns1__getPartListResponse:
		soap_serialize_ns1__getPartListResponse(soap, (const struct ns1__getPartListResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__checkLogin:
		soap_serialize_ns1__checkLogin(soap, (const struct ns1__checkLogin *)ptr);
		break;
	case SOAP_TYPE_ns1__checkLoginResponse:
		soap_serialize_ns1__checkLoginResponse(soap, (const struct ns1__checkLoginResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__updateUser:
		soap_serialize_ns1__updateUser(soap, (const struct ns1__updateUser *)ptr);
		break;
	case SOAP_TYPE_ns1__updateUserResponse:
		soap_serialize_ns1__updateUserResponse(soap, (const struct ns1__updateUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__pendingWork:
		soap_serialize_ns1__pendingWork(soap, (const struct ns1__pendingWork *)ptr);
		break;
	case SOAP_TYPE_ns1__pendingWorkResponse:
		soap_serialize_ns1__pendingWorkResponse(soap, (const struct ns1__pendingWorkResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getordercreatorbynumber:
		soap_serialize_ns1__getordercreatorbynumber(soap, (const struct ns1__getordercreatorbynumber *)ptr);
		break;
	case SOAP_TYPE_ns1__getordercreatorbynumberResponse:
		soap_serialize_ns1__getordercreatorbynumberResponse(soap, (const struct ns1__getordercreatorbynumberResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__unCheckOut:
		soap_serialize_ns1__unCheckOut(soap, (const struct ns1__unCheckOut *)ptr);
		break;
	case SOAP_TYPE_ns1__unCheckOutResponse:
		soap_serialize_ns1__unCheckOutResponse(soap, (const struct ns1__unCheckOutResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__callProduct:
		soap_serialize_ns1__callProduct(soap, (const struct ns1__callProduct *)ptr);
		break;
	case SOAP_TYPE_ns1__callProductResponse:
		soap_serialize_ns1__callProductResponse(soap, (const struct ns1__callProductResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__callCheckIn:
		soap_serialize_ns1__callCheckIn(soap, (const struct ns1__callCheckIn *)ptr);
		break;
	case SOAP_TYPE_ns1__callCheckInResponse:
		soap_serialize_ns1__callCheckInResponse(soap, (const struct ns1__callCheckInResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__callCheckOut:
		soap_serialize_ns1__callCheckOut(soap, (const struct ns1__callCheckOut *)ptr);
		break;
	case SOAP_TYPE_ns1__callCheckOutResponse:
		soap_serialize_ns1__callCheckOutResponse(soap, (const struct ns1__callCheckOutResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__callCheckUser:
		soap_serialize_ns1__callCheckUser(soap, (const struct ns1__callCheckUser *)ptr);
		break;
	case SOAP_TYPE_ns1__callCheckUserResponse:
		soap_serialize_ns1__callCheckUserResponse(soap, (const struct ns1__callCheckUserResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__callSearch:
		soap_serialize_ns1__callSearch(soap, (const struct ns1__callSearch *)ptr);
		break;
	case SOAP_TYPE_ns1__callSearchResponse:
		soap_serialize_ns1__callSearchResponse(soap, (const struct ns1__callSearchResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolder:
		soap_serialize_ns1__getFolder(soap, (const struct ns1__getFolder *)ptr);
		break;
	case SOAP_TYPE_ns1__getFolderResponse:
		soap_serialize_ns1__getFolderResponse(soap, (const struct ns1__getFolderResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getZip:
		soap_serialize_ns1__getZip(soap, (const struct ns1__getZip *)ptr);
		break;
	case SOAP_TYPE_ns1__getZipResponse:
		soap_serialize_ns1__getZipResponse(soap, (const struct ns1__getZipResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__reviseAndCheckOut:
		soap_serialize_ns1__reviseAndCheckOut(soap, (const struct ns1__reviseAndCheckOut *)ptr);
		break;
	case SOAP_TYPE_ns1__reviseAndCheckOutResponse:
		soap_serialize_ns1__reviseAndCheckOutResponse(soap, (const struct ns1__reviseAndCheckOutResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__tipicalCraftSelector:
		soap_serialize_ns1__tipicalCraftSelector(soap, (const struct ns1__tipicalCraftSelector *)ptr);
		break;
	case SOAP_TYPE_ns1__tipicalCraftSelectorResponse:
		soap_serialize_ns1__tipicalCraftSelectorResponse(soap, (const struct ns1__tipicalCraftSelectorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getorderbynumber:
		soap_serialize_ns1__getorderbynumber(soap, (const struct ns1__getorderbynumber *)ptr);
		break;
	case SOAP_TYPE_ns1__getorderbynumberResponse:
		soap_serialize_ns1__getorderbynumberResponse(soap, (const struct ns1__getorderbynumberResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__lingZuJianSelector:
		soap_serialize_ns1__lingZuJianSelector(soap, (const struct ns1__lingZuJianSelector *)ptr);
		break;
	case SOAP_TYPE_ns1__lingZuJianSelectorResponse:
		soap_serialize_ns1__lingZuJianSelectorResponse(soap, (const struct ns1__lingZuJianSelectorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__sheBeiSelector:
		soap_serialize_ns1__sheBeiSelector(soap, (const struct ns1__sheBeiSelector *)ptr);
		break;
	case SOAP_TYPE_ns1__sheBeiSelectorResponse:
		soap_serialize_ns1__sheBeiSelectorResponse(soap, (const struct ns1__sheBeiSelectorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumber:
		soap_serialize_ns1__loadAssemblePartsByPartNumber(soap, (const struct ns1__loadAssemblePartsByPartNumber *)ptr);
		break;
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse:
		soap_serialize_ns1__loadAssemblePartsByPartNumberResponse(soap, (const struct ns1__loadAssemblePartsByPartNumberResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__gongZhuangSelector:
		soap_serialize_ns1__gongZhuangSelector(soap, (const struct ns1__gongZhuangSelector *)ptr);
		break;
	case SOAP_TYPE_ns1__gongZhuangSelectorResponse:
		soap_serialize_ns1__gongZhuangSelectorResponse(soap, (const struct ns1__gongZhuangSelectorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__gongliangjiajuSelector:
		soap_serialize_ns1__gongliangjiajuSelector(soap, (const struct ns1__gongliangjiajuSelector *)ptr);
		break;
	case SOAP_TYPE_ns1__gongliangjiajuSelectorResponse:
		soap_serialize_ns1__gongliangjiajuSelectorResponse(soap, (const struct ns1__gongliangjiajuSelectorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__fuZhuJianSelector:
		soap_serialize_ns1__fuZhuJianSelector(soap, (const struct ns1__fuZhuJianSelector *)ptr);
		break;
	case SOAP_TYPE_ns1__fuZhuJianSelectorResponse:
		soap_serialize_ns1__fuZhuJianSelectorResponse(soap, (const struct ns1__fuZhuJianSelectorResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__savechangeordertowc:
		soap_serialize_ns1__savechangeordertowc(soap, (const struct ns1__savechangeordertowc *)ptr);
		break;
	case SOAP_TYPE_ns1__savechangeordertowcResponse:
		soap_serialize_ns1__savechangeordertowcResponse(soap, (const struct ns1__savechangeordertowcResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber:
		soap_serialize_ns1__getPbomOriginalItemByPartNumber(soap, (const struct ns1__getPbomOriginalItemByPartNumber *)ptr);
		break;
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse:
		soap_serialize_ns1__getPbomOriginalItemByPartNumberResponse(soap, (const struct ns1__getPbomOriginalItemByPartNumberResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumber:
		soap_serialize_ns1__getPbomEndPartByPartNumber(soap, (const struct ns1__getPbomEndPartByPartNumber *)ptr);
		break;
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse:
		soap_serialize_ns1__getPbomEndPartByPartNumberResponse(soap, (const struct ns1__getPbomEndPartByPartNumberResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getorderbyoid:
		soap_serialize_ns1__getorderbyoid(soap, (const struct ns1__getorderbyoid *)ptr);
		break;
	case SOAP_TYPE_ns1__getorderbyoidResponse:
		soap_serialize_ns1__getorderbyoidResponse(soap, (const struct ns1__getorderbyoidResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__saveordertowc:
		soap_serialize_ns1__saveordertowc(soap, (const struct ns1__saveordertowc *)ptr);
		break;
	case SOAP_TYPE_ns1__saveordertowcResponse:
		soap_serialize_ns1__saveordertowcResponse(soap, (const struct ns1__saveordertowcResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getPbomLinkByPartNumber:
		soap_serialize_ns1__getPbomLinkByPartNumber(soap, (const struct ns1__getPbomLinkByPartNumber *)ptr);
		break;
	case SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse:
		soap_serialize_ns1__getPbomLinkByPartNumberResponse(soap, (const struct ns1__getPbomLinkByPartNumberResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ping:
		soap_serialize_ns1__ping(soap, (const struct ns1__ping *)ptr);
		break;
	case SOAP_TYPE_ns1__pingResponse:
		soap_serialize_ns1__pingResponse(soap, (const struct ns1__pingResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__jmsexample:
		soap_serialize_ns1__jmsexample(soap, (const struct ns1__jmsexample *)ptr);
		break;
	case SOAP_TYPE_ns1__jmsexampleResponse:
		soap_serialize_ns1__jmsexampleResponse(soap, (const struct ns1__jmsexampleResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__GetWSDL:
		soap_serialize_ns1__GetWSDL(soap, (const struct ns1__GetWSDL *)ptr);
		break;
	case SOAP_TYPE_ns1__GetWSDLResponse:
		soap_serialize_ns1__GetWSDLResponse(soap, (const struct ns1__GetWSDLResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPC:
		soap_serialize_ns1__ExecuteSoapJmsRPC(soap, (const struct ns1__ExecuteSoapJmsRPC *)ptr);
		break;
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse:
		soap_serialize_ns1__ExecuteSoapJmsRPCResponse(soap, (const struct ns1__ExecuteSoapJmsRPCResponse *)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse:
		return (void*)soap_instantiate_ns1__ExecuteSoapJmsRPCResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPC:
		return (void*)soap_instantiate_ns1__ExecuteSoapJmsRPC(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetWSDLResponse:
		return (void*)soap_instantiate_ns1__GetWSDLResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GetWSDL:
		return (void*)soap_instantiate_ns1__GetWSDL(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jmsexampleResponse:
		return (void*)soap_instantiate_ns1__jmsexampleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__jmsexample:
		return (void*)soap_instantiate_ns1__jmsexample(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__pingResponse:
		return (void*)soap_instantiate_ns1__pingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ping:
		return (void*)soap_instantiate_ns1__ping(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse:
		return (void*)soap_instantiate_ns1__getPbomLinkByPartNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPbomLinkByPartNumber:
		return (void*)soap_instantiate_ns1__getPbomLinkByPartNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveordertowcResponse:
		return (void*)soap_instantiate_ns1__saveordertowcResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__saveordertowc:
		return (void*)soap_instantiate_ns1__saveordertowc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getorderbyoidResponse:
		return (void*)soap_instantiate_ns1__getorderbyoidResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getorderbyoid:
		return (void*)soap_instantiate_ns1__getorderbyoid(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse:
		return (void*)soap_instantiate_ns1__getPbomEndPartByPartNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumber:
		return (void*)soap_instantiate_ns1__getPbomEndPartByPartNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse:
		return (void*)soap_instantiate_ns1__getPbomOriginalItemByPartNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber:
		return (void*)soap_instantiate_ns1__getPbomOriginalItemByPartNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__savechangeordertowcResponse:
		return (void*)soap_instantiate_ns1__savechangeordertowcResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__savechangeordertowc:
		return (void*)soap_instantiate_ns1__savechangeordertowc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fuZhuJianSelectorResponse:
		return (void*)soap_instantiate_ns1__fuZhuJianSelectorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fuZhuJianSelector:
		return (void*)soap_instantiate_ns1__fuZhuJianSelector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gongliangjiajuSelectorResponse:
		return (void*)soap_instantiate_ns1__gongliangjiajuSelectorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gongliangjiajuSelector:
		return (void*)soap_instantiate_ns1__gongliangjiajuSelector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gongZhuangSelectorResponse:
		return (void*)soap_instantiate_ns1__gongZhuangSelectorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__gongZhuangSelector:
		return (void*)soap_instantiate_ns1__gongZhuangSelector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse:
		return (void*)soap_instantiate_ns1__loadAssemblePartsByPartNumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumber:
		return (void*)soap_instantiate_ns1__loadAssemblePartsByPartNumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sheBeiSelectorResponse:
		return (void*)soap_instantiate_ns1__sheBeiSelectorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sheBeiSelector:
		return (void*)soap_instantiate_ns1__sheBeiSelector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lingZuJianSelectorResponse:
		return (void*)soap_instantiate_ns1__lingZuJianSelectorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__lingZuJianSelector:
		return (void*)soap_instantiate_ns1__lingZuJianSelector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getorderbynumberResponse:
		return (void*)soap_instantiate_ns1__getorderbynumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getorderbynumber:
		return (void*)soap_instantiate_ns1__getorderbynumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__tipicalCraftSelectorResponse:
		return (void*)soap_instantiate_ns1__tipicalCraftSelectorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__tipicalCraftSelector:
		return (void*)soap_instantiate_ns1__tipicalCraftSelector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__reviseAndCheckOutResponse:
		return (void*)soap_instantiate_ns1__reviseAndCheckOutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__reviseAndCheckOut:
		return (void*)soap_instantiate_ns1__reviseAndCheckOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getZipResponse:
		return (void*)soap_instantiate_ns1__getZipResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getZip:
		return (void*)soap_instantiate_ns1__getZip(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolderResponse:
		return (void*)soap_instantiate_ns1__getFolderResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getFolder:
		return (void*)soap_instantiate_ns1__getFolder(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callSearchResponse:
		return (void*)soap_instantiate_ns1__callSearchResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callSearch:
		return (void*)soap_instantiate_ns1__callSearch(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callCheckUserResponse:
		return (void*)soap_instantiate_ns1__callCheckUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callCheckUser:
		return (void*)soap_instantiate_ns1__callCheckUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callCheckOutResponse:
		return (void*)soap_instantiate_ns1__callCheckOutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callCheckOut:
		return (void*)soap_instantiate_ns1__callCheckOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callCheckInResponse:
		return (void*)soap_instantiate_ns1__callCheckInResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callCheckIn:
		return (void*)soap_instantiate_ns1__callCheckIn(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callProductResponse:
		return (void*)soap_instantiate_ns1__callProductResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__callProduct:
		return (void*)soap_instantiate_ns1__callProduct(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unCheckOutResponse:
		return (void*)soap_instantiate_ns1__unCheckOutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unCheckOut:
		return (void*)soap_instantiate_ns1__unCheckOut(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getordercreatorbynumberResponse:
		return (void*)soap_instantiate_ns1__getordercreatorbynumberResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getordercreatorbynumber:
		return (void*)soap_instantiate_ns1__getordercreatorbynumber(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__pendingWorkResponse:
		return (void*)soap_instantiate_ns1__pendingWorkResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__pendingWork:
		return (void*)soap_instantiate_ns1__pendingWork(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateUserResponse:
		return (void*)soap_instantiate_ns1__updateUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateUser:
		return (void*)soap_instantiate_ns1__updateUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkLoginResponse:
		return (void*)soap_instantiate_ns1__checkLoginResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkLogin:
		return (void*)soap_instantiate_ns1__checkLogin(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPartListResponse:
		return (void*)soap_instantiate_ns1__getPartListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPartList:
		return (void*)soap_instantiate_ns1__getPartList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getBomResponse:
		return (void*)soap_instantiate_ns1__getBomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getBom:
		return (void*)soap_instantiate_ns1__getBom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkInPbomResponse:
		return (void*)soap_instantiate_ns1__checkInPbomResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkInPbom:
		return (void*)soap_instantiate_ns1__checkInPbom(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkInDocResponse:
		return (void*)soap_instantiate_ns1__checkInDocResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__checkInDoc:
		return (void*)soap_instantiate_ns1__checkInDoc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getBOMOfHsfResponse:
		return (void*)soap_instantiate_ns1__getBOMOfHsfResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getBOMOfHsf:
		return (void*)soap_instantiate_ns1__getBOMOfHsf(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDocInfoOfContentResponse:
		return (void*)soap_instantiate_ns1__getDocInfoOfContentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDocInfoOfContent:
		return (void*)soap_instantiate_ns1__getDocInfoOfContent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDocInfoResponse:
		return (void*)soap_instantiate_ns1__getDocInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDocInfo:
		return (void*)soap_instantiate_ns1__getDocInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SearchResourceResponse:
		return (void*)soap_instantiate_ns1__SearchResourceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SearchResource:
		return (void*)soap_instantiate_ns1__SearchResource(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__ExecuteSoapJmsRPCResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__ExecuteSoapJmsRPCResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPC:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__ExecuteSoapJmsRPC*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__ExecuteSoapJmsRPC*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__GetWSDLResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__GetWSDLResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__GetWSDLResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__GetWSDL:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__GetWSDL*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__GetWSDL*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__jmsexampleResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__jmsexampleResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__jmsexampleResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__jmsexample:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__jmsexample*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__jmsexample*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__pingResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__pingResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__pingResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ping:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__ping*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__ping*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getPbomLinkByPartNumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getPbomLinkByPartNumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getPbomLinkByPartNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getPbomLinkByPartNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getPbomLinkByPartNumber*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__saveordertowcResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__saveordertowcResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__saveordertowcResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__saveordertowc:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__saveordertowc*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__saveordertowc*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getorderbyoidResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getorderbyoidResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getorderbyoidResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getorderbyoid:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getorderbyoid*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getorderbyoid*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getPbomEndPartByPartNumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getPbomEndPartByPartNumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getPbomEndPartByPartNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getPbomEndPartByPartNumber*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getPbomOriginalItemByPartNumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getPbomOriginalItemByPartNumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getPbomOriginalItemByPartNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getPbomOriginalItemByPartNumber*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__savechangeordertowcResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__savechangeordertowcResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__savechangeordertowcResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__savechangeordertowc:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__savechangeordertowc*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__savechangeordertowc*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__fuZhuJianSelectorResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__fuZhuJianSelectorResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__fuZhuJianSelectorResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__fuZhuJianSelector:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__fuZhuJianSelector*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__fuZhuJianSelector*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__gongliangjiajuSelectorResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__gongliangjiajuSelectorResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__gongliangjiajuSelectorResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__gongliangjiajuSelector:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__gongliangjiajuSelector*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__gongliangjiajuSelector*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__gongZhuangSelectorResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__gongZhuangSelectorResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__gongZhuangSelectorResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__gongZhuangSelector:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__gongZhuangSelector*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__gongZhuangSelector*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__loadAssemblePartsByPartNumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__loadAssemblePartsByPartNumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__loadAssemblePartsByPartNumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__loadAssemblePartsByPartNumber*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__sheBeiSelectorResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__sheBeiSelectorResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__sheBeiSelectorResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__sheBeiSelector:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__sheBeiSelector*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__sheBeiSelector*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__lingZuJianSelectorResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__lingZuJianSelectorResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__lingZuJianSelectorResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__lingZuJianSelector:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__lingZuJianSelector*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__lingZuJianSelector*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getorderbynumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getorderbynumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getorderbynumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getorderbynumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getorderbynumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getorderbynumber*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__tipicalCraftSelectorResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__tipicalCraftSelectorResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__tipicalCraftSelectorResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__tipicalCraftSelector:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__tipicalCraftSelector*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__tipicalCraftSelector*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__reviseAndCheckOutResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__reviseAndCheckOutResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__reviseAndCheckOutResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__reviseAndCheckOut:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__reviseAndCheckOut*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__reviseAndCheckOut*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getZipResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getZipResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getZipResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getZip:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getZip*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getZip*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getFolderResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getFolderResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getFolderResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getFolder:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getFolder*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getFolder*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callSearchResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callSearchResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callSearchResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callSearch:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callSearch*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callSearch*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callCheckUserResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callCheckUserResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callCheckUserResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callCheckUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callCheckUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callCheckUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callCheckOutResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callCheckOutResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callCheckOutResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callCheckOut:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callCheckOut*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callCheckOut*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callCheckInResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callCheckInResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callCheckInResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callCheckIn:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callCheckIn*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callCheckIn*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callProductResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callProductResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callProductResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__callProduct:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__callProduct*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__callProduct*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__unCheckOutResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__unCheckOutResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__unCheckOutResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__unCheckOut:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__unCheckOut*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__unCheckOut*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getordercreatorbynumberResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getordercreatorbynumberResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getordercreatorbynumberResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getordercreatorbynumber:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getordercreatorbynumber*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getordercreatorbynumber*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__pendingWorkResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__pendingWorkResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__pendingWorkResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__pendingWork:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__pendingWork*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__pendingWork*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__updateUserResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__updateUserResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__updateUserResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__updateUser:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__updateUser*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__updateUser*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__checkLoginResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__checkLoginResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__checkLoginResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__checkLogin:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__checkLogin*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__checkLogin*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getPartListResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getPartListResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getPartListResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getPartList:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getPartList*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getPartList*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getBomResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getBomResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getBomResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getBom:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getBom*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getBom*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__checkInPbomResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__checkInPbomResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__checkInPbomResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__checkInPbom:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__checkInPbom*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__checkInPbom*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__checkInDocResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__checkInDocResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__checkInDocResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__checkInDoc:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__checkInDoc*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__checkInDoc*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getBOMOfHsfResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getBOMOfHsfResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getBOMOfHsfResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getBOMOfHsf:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getBOMOfHsf*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getBOMOfHsf*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getDocInfoOfContentResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getDocInfoOfContentResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getDocInfoOfContentResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getDocInfoOfContent:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getDocInfoOfContent*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getDocInfoOfContent*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getDocInfoResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getDocInfoResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getDocInfoResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__getDocInfo:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__getDocInfo*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__getDocInfo*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__SearchResourceResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__SearchResourceResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__SearchResourceResponse*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__SearchResource:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct ns1__SearchResource*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct ns1__SearchResource*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__ExecuteSoapJmsRPCResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__ExecuteSoapJmsRPCResponse*)p = *(struct ns1__ExecuteSoapJmsRPCResponse*)q;
		break;
	case SOAP_TYPE_ns1__ExecuteSoapJmsRPC:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__ExecuteSoapJmsRPC type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__ExecuteSoapJmsRPC*)p = *(struct ns1__ExecuteSoapJmsRPC*)q;
		break;
	case SOAP_TYPE_ns1__GetWSDLResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetWSDLResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetWSDLResponse*)p = *(struct ns1__GetWSDLResponse*)q;
		break;
	case SOAP_TYPE_ns1__GetWSDL:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__GetWSDL type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__GetWSDL*)p = *(struct ns1__GetWSDL*)q;
		break;
	case SOAP_TYPE_ns1__jmsexampleResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__jmsexampleResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__jmsexampleResponse*)p = *(struct ns1__jmsexampleResponse*)q;
		break;
	case SOAP_TYPE_ns1__jmsexample:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__jmsexample type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__jmsexample*)p = *(struct ns1__jmsexample*)q;
		break;
	case SOAP_TYPE_ns1__pingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__pingResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__pingResponse*)p = *(struct ns1__pingResponse*)q;
		break;
	case SOAP_TYPE_ns1__ping:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__ping type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__ping*)p = *(struct ns1__ping*)q;
		break;
	case SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getPbomLinkByPartNumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getPbomLinkByPartNumberResponse*)p = *(struct ns1__getPbomLinkByPartNumberResponse*)q;
		break;
	case SOAP_TYPE_ns1__getPbomLinkByPartNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getPbomLinkByPartNumber type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getPbomLinkByPartNumber*)p = *(struct ns1__getPbomLinkByPartNumber*)q;
		break;
	case SOAP_TYPE_ns1__saveordertowcResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__saveordertowcResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__saveordertowcResponse*)p = *(struct ns1__saveordertowcResponse*)q;
		break;
	case SOAP_TYPE_ns1__saveordertowc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__saveordertowc type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__saveordertowc*)p = *(struct ns1__saveordertowc*)q;
		break;
	case SOAP_TYPE_ns1__getorderbyoidResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getorderbyoidResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getorderbyoidResponse*)p = *(struct ns1__getorderbyoidResponse*)q;
		break;
	case SOAP_TYPE_ns1__getorderbyoid:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getorderbyoid type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getorderbyoid*)p = *(struct ns1__getorderbyoid*)q;
		break;
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getPbomEndPartByPartNumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getPbomEndPartByPartNumberResponse*)p = *(struct ns1__getPbomEndPartByPartNumberResponse*)q;
		break;
	case SOAP_TYPE_ns1__getPbomEndPartByPartNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getPbomEndPartByPartNumber type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getPbomEndPartByPartNumber*)p = *(struct ns1__getPbomEndPartByPartNumber*)q;
		break;
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getPbomOriginalItemByPartNumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getPbomOriginalItemByPartNumberResponse*)p = *(struct ns1__getPbomOriginalItemByPartNumberResponse*)q;
		break;
	case SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getPbomOriginalItemByPartNumber type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getPbomOriginalItemByPartNumber*)p = *(struct ns1__getPbomOriginalItemByPartNumber*)q;
		break;
	case SOAP_TYPE_ns1__savechangeordertowcResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__savechangeordertowcResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__savechangeordertowcResponse*)p = *(struct ns1__savechangeordertowcResponse*)q;
		break;
	case SOAP_TYPE_ns1__savechangeordertowc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__savechangeordertowc type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__savechangeordertowc*)p = *(struct ns1__savechangeordertowc*)q;
		break;
	case SOAP_TYPE_ns1__fuZhuJianSelectorResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__fuZhuJianSelectorResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__fuZhuJianSelectorResponse*)p = *(struct ns1__fuZhuJianSelectorResponse*)q;
		break;
	case SOAP_TYPE_ns1__fuZhuJianSelector:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__fuZhuJianSelector type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__fuZhuJianSelector*)p = *(struct ns1__fuZhuJianSelector*)q;
		break;
	case SOAP_TYPE_ns1__gongliangjiajuSelectorResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__gongliangjiajuSelectorResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__gongliangjiajuSelectorResponse*)p = *(struct ns1__gongliangjiajuSelectorResponse*)q;
		break;
	case SOAP_TYPE_ns1__gongliangjiajuSelector:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__gongliangjiajuSelector type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__gongliangjiajuSelector*)p = *(struct ns1__gongliangjiajuSelector*)q;
		break;
	case SOAP_TYPE_ns1__gongZhuangSelectorResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__gongZhuangSelectorResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__gongZhuangSelectorResponse*)p = *(struct ns1__gongZhuangSelectorResponse*)q;
		break;
	case SOAP_TYPE_ns1__gongZhuangSelector:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__gongZhuangSelector type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__gongZhuangSelector*)p = *(struct ns1__gongZhuangSelector*)q;
		break;
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__loadAssemblePartsByPartNumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__loadAssemblePartsByPartNumberResponse*)p = *(struct ns1__loadAssemblePartsByPartNumberResponse*)q;
		break;
	case SOAP_TYPE_ns1__loadAssemblePartsByPartNumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__loadAssemblePartsByPartNumber type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__loadAssemblePartsByPartNumber*)p = *(struct ns1__loadAssemblePartsByPartNumber*)q;
		break;
	case SOAP_TYPE_ns1__sheBeiSelectorResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__sheBeiSelectorResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__sheBeiSelectorResponse*)p = *(struct ns1__sheBeiSelectorResponse*)q;
		break;
	case SOAP_TYPE_ns1__sheBeiSelector:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__sheBeiSelector type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__sheBeiSelector*)p = *(struct ns1__sheBeiSelector*)q;
		break;
	case SOAP_TYPE_ns1__lingZuJianSelectorResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__lingZuJianSelectorResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__lingZuJianSelectorResponse*)p = *(struct ns1__lingZuJianSelectorResponse*)q;
		break;
	case SOAP_TYPE_ns1__lingZuJianSelector:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__lingZuJianSelector type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__lingZuJianSelector*)p = *(struct ns1__lingZuJianSelector*)q;
		break;
	case SOAP_TYPE_ns1__getorderbynumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getorderbynumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getorderbynumberResponse*)p = *(struct ns1__getorderbynumberResponse*)q;
		break;
	case SOAP_TYPE_ns1__getorderbynumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getorderbynumber type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getorderbynumber*)p = *(struct ns1__getorderbynumber*)q;
		break;
	case SOAP_TYPE_ns1__tipicalCraftSelectorResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__tipicalCraftSelectorResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__tipicalCraftSelectorResponse*)p = *(struct ns1__tipicalCraftSelectorResponse*)q;
		break;
	case SOAP_TYPE_ns1__tipicalCraftSelector:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__tipicalCraftSelector type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__tipicalCraftSelector*)p = *(struct ns1__tipicalCraftSelector*)q;
		break;
	case SOAP_TYPE_ns1__reviseAndCheckOutResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__reviseAndCheckOutResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__reviseAndCheckOutResponse*)p = *(struct ns1__reviseAndCheckOutResponse*)q;
		break;
	case SOAP_TYPE_ns1__reviseAndCheckOut:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__reviseAndCheckOut type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__reviseAndCheckOut*)p = *(struct ns1__reviseAndCheckOut*)q;
		break;
	case SOAP_TYPE_ns1__getZipResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getZipResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getZipResponse*)p = *(struct ns1__getZipResponse*)q;
		break;
	case SOAP_TYPE_ns1__getZip:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getZip type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getZip*)p = *(struct ns1__getZip*)q;
		break;
	case SOAP_TYPE_ns1__getFolderResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getFolderResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getFolderResponse*)p = *(struct ns1__getFolderResponse*)q;
		break;
	case SOAP_TYPE_ns1__getFolder:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getFolder type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getFolder*)p = *(struct ns1__getFolder*)q;
		break;
	case SOAP_TYPE_ns1__callSearchResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callSearchResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callSearchResponse*)p = *(struct ns1__callSearchResponse*)q;
		break;
	case SOAP_TYPE_ns1__callSearch:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callSearch type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callSearch*)p = *(struct ns1__callSearch*)q;
		break;
	case SOAP_TYPE_ns1__callCheckUserResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callCheckUserResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callCheckUserResponse*)p = *(struct ns1__callCheckUserResponse*)q;
		break;
	case SOAP_TYPE_ns1__callCheckUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callCheckUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callCheckUser*)p = *(struct ns1__callCheckUser*)q;
		break;
	case SOAP_TYPE_ns1__callCheckOutResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callCheckOutResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callCheckOutResponse*)p = *(struct ns1__callCheckOutResponse*)q;
		break;
	case SOAP_TYPE_ns1__callCheckOut:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callCheckOut type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callCheckOut*)p = *(struct ns1__callCheckOut*)q;
		break;
	case SOAP_TYPE_ns1__callCheckInResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callCheckInResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callCheckInResponse*)p = *(struct ns1__callCheckInResponse*)q;
		break;
	case SOAP_TYPE_ns1__callCheckIn:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callCheckIn type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callCheckIn*)p = *(struct ns1__callCheckIn*)q;
		break;
	case SOAP_TYPE_ns1__callProductResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callProductResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callProductResponse*)p = *(struct ns1__callProductResponse*)q;
		break;
	case SOAP_TYPE_ns1__callProduct:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__callProduct type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__callProduct*)p = *(struct ns1__callProduct*)q;
		break;
	case SOAP_TYPE_ns1__unCheckOutResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__unCheckOutResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__unCheckOutResponse*)p = *(struct ns1__unCheckOutResponse*)q;
		break;
	case SOAP_TYPE_ns1__unCheckOut:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__unCheckOut type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__unCheckOut*)p = *(struct ns1__unCheckOut*)q;
		break;
	case SOAP_TYPE_ns1__getordercreatorbynumberResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getordercreatorbynumberResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getordercreatorbynumberResponse*)p = *(struct ns1__getordercreatorbynumberResponse*)q;
		break;
	case SOAP_TYPE_ns1__getordercreatorbynumber:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getordercreatorbynumber type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getordercreatorbynumber*)p = *(struct ns1__getordercreatorbynumber*)q;
		break;
	case SOAP_TYPE_ns1__pendingWorkResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__pendingWorkResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__pendingWorkResponse*)p = *(struct ns1__pendingWorkResponse*)q;
		break;
	case SOAP_TYPE_ns1__pendingWork:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__pendingWork type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__pendingWork*)p = *(struct ns1__pendingWork*)q;
		break;
	case SOAP_TYPE_ns1__updateUserResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__updateUserResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__updateUserResponse*)p = *(struct ns1__updateUserResponse*)q;
		break;
	case SOAP_TYPE_ns1__updateUser:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__updateUser type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__updateUser*)p = *(struct ns1__updateUser*)q;
		break;
	case SOAP_TYPE_ns1__checkLoginResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__checkLoginResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__checkLoginResponse*)p = *(struct ns1__checkLoginResponse*)q;
		break;
	case SOAP_TYPE_ns1__checkLogin:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__checkLogin type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__checkLogin*)p = *(struct ns1__checkLogin*)q;
		break;
	case SOAP_TYPE_ns1__getPartListResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getPartListResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getPartListResponse*)p = *(struct ns1__getPartListResponse*)q;
		break;
	case SOAP_TYPE_ns1__getPartList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getPartList type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getPartList*)p = *(struct ns1__getPartList*)q;
		break;
	case SOAP_TYPE_ns1__getBomResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getBomResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getBomResponse*)p = *(struct ns1__getBomResponse*)q;
		break;
	case SOAP_TYPE_ns1__getBom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getBom type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getBom*)p = *(struct ns1__getBom*)q;
		break;
	case SOAP_TYPE_ns1__checkInPbomResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__checkInPbomResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__checkInPbomResponse*)p = *(struct ns1__checkInPbomResponse*)q;
		break;
	case SOAP_TYPE_ns1__checkInPbom:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__checkInPbom type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__checkInPbom*)p = *(struct ns1__checkInPbom*)q;
		break;
	case SOAP_TYPE_ns1__checkInDocResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__checkInDocResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__checkInDocResponse*)p = *(struct ns1__checkInDocResponse*)q;
		break;
	case SOAP_TYPE_ns1__checkInDoc:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__checkInDoc type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__checkInDoc*)p = *(struct ns1__checkInDoc*)q;
		break;
	case SOAP_TYPE_ns1__getBOMOfHsfResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getBOMOfHsfResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getBOMOfHsfResponse*)p = *(struct ns1__getBOMOfHsfResponse*)q;
		break;
	case SOAP_TYPE_ns1__getBOMOfHsf:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getBOMOfHsf type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getBOMOfHsf*)p = *(struct ns1__getBOMOfHsf*)q;
		break;
	case SOAP_TYPE_ns1__getDocInfoOfContentResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getDocInfoOfContentResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getDocInfoOfContentResponse*)p = *(struct ns1__getDocInfoOfContentResponse*)q;
		break;
	case SOAP_TYPE_ns1__getDocInfoOfContent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getDocInfoOfContent type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getDocInfoOfContent*)p = *(struct ns1__getDocInfoOfContent*)q;
		break;
	case SOAP_TYPE_ns1__getDocInfoResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getDocInfoResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getDocInfoResponse*)p = *(struct ns1__getDocInfoResponse*)q;
		break;
	case SOAP_TYPE_ns1__getDocInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__getDocInfo type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__getDocInfo*)p = *(struct ns1__getDocInfo*)q;
		break;
	case SOAP_TYPE_ns1__SearchResourceResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SearchResourceResponse type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SearchResourceResponse*)p = *(struct ns1__SearchResourceResponse*)q;
		break;
	case SOAP_TYPE_ns1__SearchResource:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct ns1__SearchResource type=%d location=%p object=%p\n", t, p, q));
		*(struct ns1__SearchResource*)p = *(struct ns1__SearchResource*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SearchResource(struct soap *soap, struct ns1__SearchResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->operType);
	soap_default_string(soap, &a->resourceNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SearchResource(struct soap *soap, const struct ns1__SearchResource *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->operType);
	soap_serialize_string(soap, (char*const*)&a->resourceNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SearchResource(struct soap *soap, const char *tag, int id, const struct ns1__SearchResource *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SearchResource), type))
		return soap->error;
	if (soap_out_string(soap, "operType", -1, (char*const*)&a->operType, ""))
		return soap->error;
	if (soap_out_string(soap, "resourceNumber", -1, (char*const*)&a->resourceNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SearchResource * SOAP_FMAC4 soap_in_ns1__SearchResource(struct soap *soap, const char *tag, struct ns1__SearchResource *a, const char *type)
{
	size_t soap_flag_operType = 1;
	size_t soap_flag_resourceNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SearchResource *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SearchResource, sizeof(struct ns1__SearchResource), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SearchResource(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "operType", (char**)&a->operType, "xsd:string"))
				{	soap_flag_operType--;
					continue;
				}
			if (soap_flag_resourceNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "resourceNumber", (char**)&a->resourceNumber, "xsd:string"))
				{	soap_flag_resourceNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SearchResource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SearchResource, SOAP_TYPE_ns1__SearchResource, sizeof(struct ns1__SearchResource), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SearchResource * SOAP_FMAC2 soap_instantiate_ns1__SearchResource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SearchResource(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SearchResource *p;
	size_t k = sizeof(struct ns1__SearchResource);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__SearchResource);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__SearchResource, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SearchResource location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__SearchResource, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SearchResource(struct soap *soap, const struct ns1__SearchResource *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SearchResource(soap, tag ? tag : "ns1:SearchResource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SearchResource * SOAP_FMAC4 soap_get_ns1__SearchResource(struct soap *soap, struct ns1__SearchResource *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SearchResource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SearchResourceResponse(struct soap *soap, struct ns1__SearchResourceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SearchResourceResponse(struct soap *soap, const struct ns1__SearchResourceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SearchResourceResponse(struct soap *soap, const char *tag, int id, const struct ns1__SearchResourceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SearchResourceResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SearchResourceResponse * SOAP_FMAC4 soap_in_ns1__SearchResourceResponse(struct soap *soap, const char *tag, struct ns1__SearchResourceResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SearchResourceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SearchResourceResponse, sizeof(struct ns1__SearchResourceResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SearchResourceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__SearchResourceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SearchResourceResponse, SOAP_TYPE_ns1__SearchResourceResponse, sizeof(struct ns1__SearchResourceResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__SearchResourceResponse * SOAP_FMAC2 soap_instantiate_ns1__SearchResourceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SearchResourceResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__SearchResourceResponse *p;
	size_t k = sizeof(struct ns1__SearchResourceResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__SearchResourceResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__SearchResourceResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__SearchResourceResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__SearchResourceResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SearchResourceResponse(struct soap *soap, const struct ns1__SearchResourceResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SearchResourceResponse(soap, tag ? tag : "ns1:SearchResourceResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SearchResourceResponse * SOAP_FMAC4 soap_get_ns1__SearchResourceResponse(struct soap *soap, struct ns1__SearchResourceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SearchResourceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDocInfo(struct soap *soap, struct ns1__getDocInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->operType);
	soap_default_string(soap, &a->docNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDocInfo(struct soap *soap, const struct ns1__getDocInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->operType);
	soap_serialize_string(soap, (char*const*)&a->docNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDocInfo(struct soap *soap, const char *tag, int id, const struct ns1__getDocInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDocInfo), type))
		return soap->error;
	if (soap_out_string(soap, "operType", -1, (char*const*)&a->operType, ""))
		return soap->error;
	if (soap_out_string(soap, "docNumber", -1, (char*const*)&a->docNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDocInfo * SOAP_FMAC4 soap_in_ns1__getDocInfo(struct soap *soap, const char *tag, struct ns1__getDocInfo *a, const char *type)
{
	size_t soap_flag_operType = 1;
	size_t soap_flag_docNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDocInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDocInfo, sizeof(struct ns1__getDocInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDocInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "operType", (char**)&a->operType, "xsd:string"))
				{	soap_flag_operType--;
					continue;
				}
			if (soap_flag_docNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "docNumber", (char**)&a->docNumber, "xsd:string"))
				{	soap_flag_docNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDocInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDocInfo, SOAP_TYPE_ns1__getDocInfo, sizeof(struct ns1__getDocInfo), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getDocInfo * SOAP_FMAC2 soap_instantiate_ns1__getDocInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDocInfo(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getDocInfo *p;
	size_t k = sizeof(struct ns1__getDocInfo);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getDocInfo);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getDocInfo, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getDocInfo location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getDocInfo, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDocInfo(struct soap *soap, const struct ns1__getDocInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getDocInfo(soap, tag ? tag : "ns1:getDocInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDocInfo * SOAP_FMAC4 soap_get_ns1__getDocInfo(struct soap *soap, struct ns1__getDocInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDocInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDocInfoResponse(struct soap *soap, struct ns1__getDocInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDocInfoResponse(struct soap *soap, const struct ns1__getDocInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDocInfoResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDocInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDocInfoResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDocInfoResponse * SOAP_FMAC4 soap_in_ns1__getDocInfoResponse(struct soap *soap, const char *tag, struct ns1__getDocInfoResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDocInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDocInfoResponse, sizeof(struct ns1__getDocInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDocInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getDocInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDocInfoResponse, SOAP_TYPE_ns1__getDocInfoResponse, sizeof(struct ns1__getDocInfoResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getDocInfoResponse * SOAP_FMAC2 soap_instantiate_ns1__getDocInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDocInfoResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getDocInfoResponse *p;
	size_t k = sizeof(struct ns1__getDocInfoResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getDocInfoResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getDocInfoResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getDocInfoResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getDocInfoResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDocInfoResponse(struct soap *soap, const struct ns1__getDocInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getDocInfoResponse(soap, tag ? tag : "ns1:getDocInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDocInfoResponse * SOAP_FMAC4 soap_get_ns1__getDocInfoResponse(struct soap *soap, struct ns1__getDocInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDocInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDocInfoOfContent(struct soap *soap, struct ns1__getDocInfoOfContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->operType);
	soap_default_string(soap, &a->docNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDocInfoOfContent(struct soap *soap, const struct ns1__getDocInfoOfContent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->operType);
	soap_serialize_string(soap, (char*const*)&a->docNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDocInfoOfContent(struct soap *soap, const char *tag, int id, const struct ns1__getDocInfoOfContent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDocInfoOfContent), type))
		return soap->error;
	if (soap_out_string(soap, "operType", -1, (char*const*)&a->operType, ""))
		return soap->error;
	if (soap_out_string(soap, "docNumber", -1, (char*const*)&a->docNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDocInfoOfContent * SOAP_FMAC4 soap_in_ns1__getDocInfoOfContent(struct soap *soap, const char *tag, struct ns1__getDocInfoOfContent *a, const char *type)
{
	size_t soap_flag_operType = 1;
	size_t soap_flag_docNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDocInfoOfContent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDocInfoOfContent, sizeof(struct ns1__getDocInfoOfContent), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDocInfoOfContent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "operType", (char**)&a->operType, "xsd:string"))
				{	soap_flag_operType--;
					continue;
				}
			if (soap_flag_docNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "docNumber", (char**)&a->docNumber, "xsd:string"))
				{	soap_flag_docNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDocInfoOfContent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDocInfoOfContent, SOAP_TYPE_ns1__getDocInfoOfContent, sizeof(struct ns1__getDocInfoOfContent), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getDocInfoOfContent * SOAP_FMAC2 soap_instantiate_ns1__getDocInfoOfContent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDocInfoOfContent(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getDocInfoOfContent *p;
	size_t k = sizeof(struct ns1__getDocInfoOfContent);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getDocInfoOfContent);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getDocInfoOfContent, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getDocInfoOfContent location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getDocInfoOfContent, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDocInfoOfContent(struct soap *soap, const struct ns1__getDocInfoOfContent *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getDocInfoOfContent(soap, tag ? tag : "ns1:getDocInfoOfContent", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDocInfoOfContent * SOAP_FMAC4 soap_get_ns1__getDocInfoOfContent(struct soap *soap, struct ns1__getDocInfoOfContent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDocInfoOfContent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDocInfoOfContentResponse(struct soap *soap, struct ns1__getDocInfoOfContentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDocInfoOfContentResponse(struct soap *soap, const struct ns1__getDocInfoOfContentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDocInfoOfContentResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDocInfoOfContentResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDocInfoOfContentResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDocInfoOfContentResponse * SOAP_FMAC4 soap_in_ns1__getDocInfoOfContentResponse(struct soap *soap, const char *tag, struct ns1__getDocInfoOfContentResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDocInfoOfContentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDocInfoOfContentResponse, sizeof(struct ns1__getDocInfoOfContentResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDocInfoOfContentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getDocInfoOfContentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDocInfoOfContentResponse, SOAP_TYPE_ns1__getDocInfoOfContentResponse, sizeof(struct ns1__getDocInfoOfContentResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getDocInfoOfContentResponse * SOAP_FMAC2 soap_instantiate_ns1__getDocInfoOfContentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDocInfoOfContentResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getDocInfoOfContentResponse *p;
	size_t k = sizeof(struct ns1__getDocInfoOfContentResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getDocInfoOfContentResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getDocInfoOfContentResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getDocInfoOfContentResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getDocInfoOfContentResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDocInfoOfContentResponse(struct soap *soap, const struct ns1__getDocInfoOfContentResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getDocInfoOfContentResponse(soap, tag ? tag : "ns1:getDocInfoOfContentResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getDocInfoOfContentResponse * SOAP_FMAC4 soap_get_ns1__getDocInfoOfContentResponse(struct soap *soap, struct ns1__getDocInfoOfContentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDocInfoOfContentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getBOMOfHsf(struct soap *soap, struct ns1__getBOMOfHsf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->operType);
	soap_default_string(soap, &a->partNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getBOMOfHsf(struct soap *soap, const struct ns1__getBOMOfHsf *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->operType);
	soap_serialize_string(soap, (char*const*)&a->partNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getBOMOfHsf(struct soap *soap, const char *tag, int id, const struct ns1__getBOMOfHsf *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getBOMOfHsf), type))
		return soap->error;
	if (soap_out_string(soap, "operType", -1, (char*const*)&a->operType, ""))
		return soap->error;
	if (soap_out_string(soap, "partNumber", -1, (char*const*)&a->partNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getBOMOfHsf * SOAP_FMAC4 soap_in_ns1__getBOMOfHsf(struct soap *soap, const char *tag, struct ns1__getBOMOfHsf *a, const char *type)
{
	size_t soap_flag_operType = 1;
	size_t soap_flag_partNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getBOMOfHsf *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getBOMOfHsf, sizeof(struct ns1__getBOMOfHsf), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getBOMOfHsf(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "operType", (char**)&a->operType, "xsd:string"))
				{	soap_flag_operType--;
					continue;
				}
			if (soap_flag_partNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "partNumber", (char**)&a->partNumber, "xsd:string"))
				{	soap_flag_partNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getBOMOfHsf *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getBOMOfHsf, SOAP_TYPE_ns1__getBOMOfHsf, sizeof(struct ns1__getBOMOfHsf), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getBOMOfHsf * SOAP_FMAC2 soap_instantiate_ns1__getBOMOfHsf(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getBOMOfHsf(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getBOMOfHsf *p;
	size_t k = sizeof(struct ns1__getBOMOfHsf);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getBOMOfHsf);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getBOMOfHsf, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getBOMOfHsf location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getBOMOfHsf, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getBOMOfHsf(struct soap *soap, const struct ns1__getBOMOfHsf *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getBOMOfHsf(soap, tag ? tag : "ns1:getBOMOfHsf", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getBOMOfHsf * SOAP_FMAC4 soap_get_ns1__getBOMOfHsf(struct soap *soap, struct ns1__getBOMOfHsf *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getBOMOfHsf(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getBOMOfHsfResponse(struct soap *soap, struct ns1__getBOMOfHsfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getBOMOfHsfResponse(struct soap *soap, const struct ns1__getBOMOfHsfResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getBOMOfHsfResponse(struct soap *soap, const char *tag, int id, const struct ns1__getBOMOfHsfResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getBOMOfHsfResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getBOMOfHsfResponse * SOAP_FMAC4 soap_in_ns1__getBOMOfHsfResponse(struct soap *soap, const char *tag, struct ns1__getBOMOfHsfResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getBOMOfHsfResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getBOMOfHsfResponse, sizeof(struct ns1__getBOMOfHsfResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getBOMOfHsfResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getBOMOfHsfResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getBOMOfHsfResponse, SOAP_TYPE_ns1__getBOMOfHsfResponse, sizeof(struct ns1__getBOMOfHsfResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getBOMOfHsfResponse * SOAP_FMAC2 soap_instantiate_ns1__getBOMOfHsfResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getBOMOfHsfResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getBOMOfHsfResponse *p;
	size_t k = sizeof(struct ns1__getBOMOfHsfResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getBOMOfHsfResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getBOMOfHsfResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getBOMOfHsfResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getBOMOfHsfResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getBOMOfHsfResponse(struct soap *soap, const struct ns1__getBOMOfHsfResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getBOMOfHsfResponse(soap, tag ? tag : "ns1:getBOMOfHsfResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getBOMOfHsfResponse * SOAP_FMAC4 soap_get_ns1__getBOMOfHsfResponse(struct soap *soap, struct ns1__getBOMOfHsfResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getBOMOfHsfResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkInDoc(struct soap *soap, struct ns1__checkInDoc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->operType);
	soap_default_string(soap, &a->fileName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkInDoc(struct soap *soap, const struct ns1__checkInDoc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->operType);
	soap_serialize_string(soap, (char*const*)&a->fileName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkInDoc(struct soap *soap, const char *tag, int id, const struct ns1__checkInDoc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkInDoc), type))
		return soap->error;
	if (soap_out_string(soap, "operType", -1, (char*const*)&a->operType, ""))
		return soap->error;
	if (soap_out_string(soap, "fileName", -1, (char*const*)&a->fileName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkInDoc * SOAP_FMAC4 soap_in_ns1__checkInDoc(struct soap *soap, const char *tag, struct ns1__checkInDoc *a, const char *type)
{
	size_t soap_flag_operType = 1;
	size_t soap_flag_fileName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkInDoc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkInDoc, sizeof(struct ns1__checkInDoc), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkInDoc(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "operType", (char**)&a->operType, "xsd:string"))
				{	soap_flag_operType--;
					continue;
				}
			if (soap_flag_fileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileName", (char**)&a->fileName, "xsd:string"))
				{	soap_flag_fileName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkInDoc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkInDoc, SOAP_TYPE_ns1__checkInDoc, sizeof(struct ns1__checkInDoc), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__checkInDoc * SOAP_FMAC2 soap_instantiate_ns1__checkInDoc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkInDoc(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__checkInDoc *p;
	size_t k = sizeof(struct ns1__checkInDoc);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__checkInDoc);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__checkInDoc, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__checkInDoc location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__checkInDoc, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkInDoc(struct soap *soap, const struct ns1__checkInDoc *a, const char *tag, const char *type)
{
	if (soap_out_ns1__checkInDoc(soap, tag ? tag : "ns1:checkInDoc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkInDoc * SOAP_FMAC4 soap_get_ns1__checkInDoc(struct soap *soap, struct ns1__checkInDoc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkInDoc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkInDocResponse(struct soap *soap, struct ns1__checkInDocResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkInDocResponse(struct soap *soap, const struct ns1__checkInDocResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkInDocResponse(struct soap *soap, const char *tag, int id, const struct ns1__checkInDocResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkInDocResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkInDocResponse * SOAP_FMAC4 soap_in_ns1__checkInDocResponse(struct soap *soap, const char *tag, struct ns1__checkInDocResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkInDocResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkInDocResponse, sizeof(struct ns1__checkInDocResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkInDocResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__checkInDocResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkInDocResponse, SOAP_TYPE_ns1__checkInDocResponse, sizeof(struct ns1__checkInDocResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__checkInDocResponse * SOAP_FMAC2 soap_instantiate_ns1__checkInDocResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkInDocResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__checkInDocResponse *p;
	size_t k = sizeof(struct ns1__checkInDocResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__checkInDocResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__checkInDocResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__checkInDocResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__checkInDocResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkInDocResponse(struct soap *soap, const struct ns1__checkInDocResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__checkInDocResponse(soap, tag ? tag : "ns1:checkInDocResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkInDocResponse * SOAP_FMAC4 soap_get_ns1__checkInDocResponse(struct soap *soap, struct ns1__checkInDocResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkInDocResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkInPbom(struct soap *soap, struct ns1__checkInPbom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkInPbom(struct soap *soap, const struct ns1__checkInPbom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->fileName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkInPbom(struct soap *soap, const char *tag, int id, const struct ns1__checkInPbom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkInPbom), type))
		return soap->error;
	if (soap_out_string(soap, "fileName", -1, (char*const*)&a->fileName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkInPbom * SOAP_FMAC4 soap_in_ns1__checkInPbom(struct soap *soap, const char *tag, struct ns1__checkInPbom *a, const char *type)
{
	size_t soap_flag_fileName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkInPbom *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkInPbom, sizeof(struct ns1__checkInPbom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkInPbom(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileName", (char**)&a->fileName, "xsd:string"))
				{	soap_flag_fileName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkInPbom *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkInPbom, SOAP_TYPE_ns1__checkInPbom, sizeof(struct ns1__checkInPbom), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__checkInPbom * SOAP_FMAC2 soap_instantiate_ns1__checkInPbom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkInPbom(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__checkInPbom *p;
	size_t k = sizeof(struct ns1__checkInPbom);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__checkInPbom);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__checkInPbom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__checkInPbom location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__checkInPbom, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkInPbom(struct soap *soap, const struct ns1__checkInPbom *a, const char *tag, const char *type)
{
	if (soap_out_ns1__checkInPbom(soap, tag ? tag : "ns1:checkInPbom", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkInPbom * SOAP_FMAC4 soap_get_ns1__checkInPbom(struct soap *soap, struct ns1__checkInPbom *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkInPbom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkInPbomResponse(struct soap *soap, struct ns1__checkInPbomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkInPbomResponse(struct soap *soap, const struct ns1__checkInPbomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkInPbomResponse(struct soap *soap, const char *tag, int id, const struct ns1__checkInPbomResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkInPbomResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkInPbomResponse * SOAP_FMAC4 soap_in_ns1__checkInPbomResponse(struct soap *soap, const char *tag, struct ns1__checkInPbomResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkInPbomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkInPbomResponse, sizeof(struct ns1__checkInPbomResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkInPbomResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__checkInPbomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkInPbomResponse, SOAP_TYPE_ns1__checkInPbomResponse, sizeof(struct ns1__checkInPbomResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__checkInPbomResponse * SOAP_FMAC2 soap_instantiate_ns1__checkInPbomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkInPbomResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__checkInPbomResponse *p;
	size_t k = sizeof(struct ns1__checkInPbomResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__checkInPbomResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__checkInPbomResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__checkInPbomResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__checkInPbomResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkInPbomResponse(struct soap *soap, const struct ns1__checkInPbomResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__checkInPbomResponse(soap, tag ? tag : "ns1:checkInPbomResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkInPbomResponse * SOAP_FMAC4 soap_get_ns1__checkInPbomResponse(struct soap *soap, struct ns1__checkInPbomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkInPbomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getBom(struct soap *soap, struct ns1__getBom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->operType);
	soap_default_string(soap, &a->partNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getBom(struct soap *soap, const struct ns1__getBom *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->operType);
	soap_serialize_string(soap, (char*const*)&a->partNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getBom(struct soap *soap, const char *tag, int id, const struct ns1__getBom *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getBom), type))
		return soap->error;
	if (soap_out_string(soap, "operType", -1, (char*const*)&a->operType, ""))
		return soap->error;
	if (soap_out_string(soap, "partNumber", -1, (char*const*)&a->partNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getBom * SOAP_FMAC4 soap_in_ns1__getBom(struct soap *soap, const char *tag, struct ns1__getBom *a, const char *type)
{
	size_t soap_flag_operType = 1;
	size_t soap_flag_partNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getBom *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getBom, sizeof(struct ns1__getBom), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getBom(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "operType", (char**)&a->operType, "xsd:string"))
				{	soap_flag_operType--;
					continue;
				}
			if (soap_flag_partNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "partNumber", (char**)&a->partNumber, "xsd:string"))
				{	soap_flag_partNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getBom *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getBom, SOAP_TYPE_ns1__getBom, sizeof(struct ns1__getBom), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getBom * SOAP_FMAC2 soap_instantiate_ns1__getBom(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getBom(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getBom *p;
	size_t k = sizeof(struct ns1__getBom);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getBom);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getBom, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getBom location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getBom, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getBom(struct soap *soap, const struct ns1__getBom *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getBom(soap, tag ? tag : "ns1:getBom", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getBom * SOAP_FMAC4 soap_get_ns1__getBom(struct soap *soap, struct ns1__getBom *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getBom(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getBomResponse(struct soap *soap, struct ns1__getBomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getBomResponse(struct soap *soap, const struct ns1__getBomResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getBomResponse(struct soap *soap, const char *tag, int id, const struct ns1__getBomResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getBomResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getBomResponse * SOAP_FMAC4 soap_in_ns1__getBomResponse(struct soap *soap, const char *tag, struct ns1__getBomResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getBomResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getBomResponse, sizeof(struct ns1__getBomResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getBomResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getBomResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getBomResponse, SOAP_TYPE_ns1__getBomResponse, sizeof(struct ns1__getBomResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getBomResponse * SOAP_FMAC2 soap_instantiate_ns1__getBomResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getBomResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getBomResponse *p;
	size_t k = sizeof(struct ns1__getBomResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getBomResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getBomResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getBomResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getBomResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getBomResponse(struct soap *soap, const struct ns1__getBomResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getBomResponse(soap, tag ? tag : "ns1:getBomResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getBomResponse * SOAP_FMAC4 soap_get_ns1__getBomResponse(struct soap *soap, struct ns1__getBomResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getBomResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPartList(struct soap *soap, struct ns1__getPartList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->operType);
	soap_default_string(soap, &a->partNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPartList(struct soap *soap, const struct ns1__getPartList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->operType);
	soap_serialize_string(soap, (char*const*)&a->partNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPartList(struct soap *soap, const char *tag, int id, const struct ns1__getPartList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPartList), type))
		return soap->error;
	if (soap_out_string(soap, "operType", -1, (char*const*)&a->operType, ""))
		return soap->error;
	if (soap_out_string(soap, "partNumber", -1, (char*const*)&a->partNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPartList * SOAP_FMAC4 soap_in_ns1__getPartList(struct soap *soap, const char *tag, struct ns1__getPartList *a, const char *type)
{
	size_t soap_flag_operType = 1;
	size_t soap_flag_partNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPartList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPartList, sizeof(struct ns1__getPartList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getPartList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_operType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "operType", (char**)&a->operType, "xsd:string"))
				{	soap_flag_operType--;
					continue;
				}
			if (soap_flag_partNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "partNumber", (char**)&a->partNumber, "xsd:string"))
				{	soap_flag_partNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getPartList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPartList, SOAP_TYPE_ns1__getPartList, sizeof(struct ns1__getPartList), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getPartList * SOAP_FMAC2 soap_instantiate_ns1__getPartList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPartList(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getPartList *p;
	size_t k = sizeof(struct ns1__getPartList);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getPartList);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getPartList, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getPartList location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getPartList, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPartList(struct soap *soap, const struct ns1__getPartList *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getPartList(soap, tag ? tag : "ns1:getPartList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPartList * SOAP_FMAC4 soap_get_ns1__getPartList(struct soap *soap, struct ns1__getPartList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPartList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPartListResponse(struct soap *soap, struct ns1__getPartListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPartListResponse(struct soap *soap, const struct ns1__getPartListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPartListResponse(struct soap *soap, const char *tag, int id, const struct ns1__getPartListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPartListResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPartListResponse * SOAP_FMAC4 soap_in_ns1__getPartListResponse(struct soap *soap, const char *tag, struct ns1__getPartListResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPartListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPartListResponse, sizeof(struct ns1__getPartListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getPartListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getPartListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPartListResponse, SOAP_TYPE_ns1__getPartListResponse, sizeof(struct ns1__getPartListResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getPartListResponse * SOAP_FMAC2 soap_instantiate_ns1__getPartListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPartListResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getPartListResponse *p;
	size_t k = sizeof(struct ns1__getPartListResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getPartListResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getPartListResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getPartListResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getPartListResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPartListResponse(struct soap *soap, const struct ns1__getPartListResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getPartListResponse(soap, tag ? tag : "ns1:getPartListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPartListResponse * SOAP_FMAC4 soap_get_ns1__getPartListResponse(struct soap *soap, struct ns1__getPartListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPartListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkLogin(struct soap *soap, struct ns1__checkLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkLogin(struct soap *soap, const struct ns1__checkLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkLogin(struct soap *soap, const char *tag, int id, const struct ns1__checkLogin *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkLogin), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkLogin * SOAP_FMAC4 soap_in_ns1__checkLogin(struct soap *soap, const char *tag, struct ns1__checkLogin *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkLogin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkLogin, sizeof(struct ns1__checkLogin), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkLogin(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__checkLogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkLogin, SOAP_TYPE_ns1__checkLogin, sizeof(struct ns1__checkLogin), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__checkLogin * SOAP_FMAC2 soap_instantiate_ns1__checkLogin(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkLogin(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__checkLogin *p;
	size_t k = sizeof(struct ns1__checkLogin);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__checkLogin);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__checkLogin, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__checkLogin location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__checkLogin, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkLogin(struct soap *soap, const struct ns1__checkLogin *a, const char *tag, const char *type)
{
	if (soap_out_ns1__checkLogin(soap, tag ? tag : "ns1:checkLogin", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkLogin * SOAP_FMAC4 soap_get_ns1__checkLogin(struct soap *soap, struct ns1__checkLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__checkLoginResponse(struct soap *soap, struct ns1__checkLoginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__checkLoginResponse(struct soap *soap, const struct ns1__checkLoginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__checkLoginResponse(struct soap *soap, const char *tag, int id, const struct ns1__checkLoginResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__checkLoginResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__checkLoginResponse * SOAP_FMAC4 soap_in_ns1__checkLoginResponse(struct soap *soap, const char *tag, struct ns1__checkLoginResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__checkLoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__checkLoginResponse, sizeof(struct ns1__checkLoginResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__checkLoginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__checkLoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__checkLoginResponse, SOAP_TYPE_ns1__checkLoginResponse, sizeof(struct ns1__checkLoginResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__checkLoginResponse * SOAP_FMAC2 soap_instantiate_ns1__checkLoginResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__checkLoginResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__checkLoginResponse *p;
	size_t k = sizeof(struct ns1__checkLoginResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__checkLoginResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__checkLoginResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__checkLoginResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__checkLoginResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__checkLoginResponse(struct soap *soap, const struct ns1__checkLoginResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__checkLoginResponse(soap, tag ? tag : "ns1:checkLoginResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__checkLoginResponse * SOAP_FMAC4 soap_get_ns1__checkLoginResponse(struct soap *soap, struct ns1__checkLoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__checkLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__updateUser(struct soap *soap, struct ns1__updateUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__updateUser(struct soap *soap, const struct ns1__updateUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateUser(struct soap *soap, const char *tag, int id, const struct ns1__updateUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateUser), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__updateUser * SOAP_FMAC4 soap_in_ns1__updateUser(struct soap *soap, const char *tag, struct ns1__updateUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__updateUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateUser, sizeof(struct ns1__updateUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__updateUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__updateUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateUser, SOAP_TYPE_ns1__updateUser, sizeof(struct ns1__updateUser), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__updateUser * SOAP_FMAC2 soap_instantiate_ns1__updateUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateUser(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__updateUser *p;
	size_t k = sizeof(struct ns1__updateUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__updateUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__updateUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__updateUser location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__updateUser, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__updateUser(struct soap *soap, const struct ns1__updateUser *a, const char *tag, const char *type)
{
	if (soap_out_ns1__updateUser(soap, tag ? tag : "ns1:updateUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__updateUser * SOAP_FMAC4 soap_get_ns1__updateUser(struct soap *soap, struct ns1__updateUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__updateUserResponse(struct soap *soap, struct ns1__updateUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__updateUserResponse(struct soap *soap, const struct ns1__updateUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__updateUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateUserResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__updateUserResponse * SOAP_FMAC4 soap_in_ns1__updateUserResponse(struct soap *soap, const char *tag, struct ns1__updateUserResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__updateUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateUserResponse, sizeof(struct ns1__updateUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__updateUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__updateUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateUserResponse, SOAP_TYPE_ns1__updateUserResponse, sizeof(struct ns1__updateUserResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__updateUserResponse * SOAP_FMAC2 soap_instantiate_ns1__updateUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateUserResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__updateUserResponse *p;
	size_t k = sizeof(struct ns1__updateUserResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__updateUserResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__updateUserResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__updateUserResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__updateUserResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__updateUserResponse(struct soap *soap, const struct ns1__updateUserResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__updateUserResponse(soap, tag ? tag : "ns1:updateUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__updateUserResponse * SOAP_FMAC4 soap_get_ns1__updateUserResponse(struct soap *soap, struct ns1__updateUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__pendingWork(struct soap *soap, struct ns1__pendingWork *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__pendingWork(struct soap *soap, const struct ns1__pendingWork *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__pendingWork(struct soap *soap, const char *tag, int id, const struct ns1__pendingWork *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__pendingWork), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__pendingWork * SOAP_FMAC4 soap_in_ns1__pendingWork(struct soap *soap, const char *tag, struct ns1__pendingWork *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__pendingWork *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__pendingWork, sizeof(struct ns1__pendingWork), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__pendingWork(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__pendingWork *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__pendingWork, SOAP_TYPE_ns1__pendingWork, sizeof(struct ns1__pendingWork), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__pendingWork * SOAP_FMAC2 soap_instantiate_ns1__pendingWork(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__pendingWork(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__pendingWork *p;
	size_t k = sizeof(struct ns1__pendingWork);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__pendingWork);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__pendingWork, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__pendingWork location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__pendingWork, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__pendingWork(struct soap *soap, const struct ns1__pendingWork *a, const char *tag, const char *type)
{
	if (soap_out_ns1__pendingWork(soap, tag ? tag : "ns1:pendingWork", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__pendingWork * SOAP_FMAC4 soap_get_ns1__pendingWork(struct soap *soap, struct ns1__pendingWork *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__pendingWork(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__pendingWorkResponse(struct soap *soap, struct ns1__pendingWorkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__pendingWorkResponse(struct soap *soap, const struct ns1__pendingWorkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__pendingWorkResponse(struct soap *soap, const char *tag, int id, const struct ns1__pendingWorkResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__pendingWorkResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__pendingWorkResponse * SOAP_FMAC4 soap_in_ns1__pendingWorkResponse(struct soap *soap, const char *tag, struct ns1__pendingWorkResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__pendingWorkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__pendingWorkResponse, sizeof(struct ns1__pendingWorkResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__pendingWorkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__pendingWorkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__pendingWorkResponse, SOAP_TYPE_ns1__pendingWorkResponse, sizeof(struct ns1__pendingWorkResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__pendingWorkResponse * SOAP_FMAC2 soap_instantiate_ns1__pendingWorkResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__pendingWorkResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__pendingWorkResponse *p;
	size_t k = sizeof(struct ns1__pendingWorkResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__pendingWorkResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__pendingWorkResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__pendingWorkResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__pendingWorkResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__pendingWorkResponse(struct soap *soap, const struct ns1__pendingWorkResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__pendingWorkResponse(soap, tag ? tag : "ns1:pendingWorkResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__pendingWorkResponse * SOAP_FMAC4 soap_get_ns1__pendingWorkResponse(struct soap *soap, struct ns1__pendingWorkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__pendingWorkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getordercreatorbynumber(struct soap *soap, struct ns1__getordercreatorbynumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getordercreatorbynumber(struct soap *soap, const struct ns1__getordercreatorbynumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getordercreatorbynumber(struct soap *soap, const char *tag, int id, const struct ns1__getordercreatorbynumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getordercreatorbynumber), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getordercreatorbynumber * SOAP_FMAC4 soap_in_ns1__getordercreatorbynumber(struct soap *soap, const char *tag, struct ns1__getordercreatorbynumber *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getordercreatorbynumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getordercreatorbynumber, sizeof(struct ns1__getordercreatorbynumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getordercreatorbynumber(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getordercreatorbynumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getordercreatorbynumber, SOAP_TYPE_ns1__getordercreatorbynumber, sizeof(struct ns1__getordercreatorbynumber), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getordercreatorbynumber * SOAP_FMAC2 soap_instantiate_ns1__getordercreatorbynumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getordercreatorbynumber(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getordercreatorbynumber *p;
	size_t k = sizeof(struct ns1__getordercreatorbynumber);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getordercreatorbynumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getordercreatorbynumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getordercreatorbynumber location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getordercreatorbynumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getordercreatorbynumber(struct soap *soap, const struct ns1__getordercreatorbynumber *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getordercreatorbynumber(soap, tag ? tag : "ns1:getordercreatorbynumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getordercreatorbynumber * SOAP_FMAC4 soap_get_ns1__getordercreatorbynumber(struct soap *soap, struct ns1__getordercreatorbynumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getordercreatorbynumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getordercreatorbynumberResponse(struct soap *soap, struct ns1__getordercreatorbynumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getordercreatorbynumberResponse(struct soap *soap, const struct ns1__getordercreatorbynumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getordercreatorbynumberResponse(struct soap *soap, const char *tag, int id, const struct ns1__getordercreatorbynumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getordercreatorbynumberResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getordercreatorbynumberResponse * SOAP_FMAC4 soap_in_ns1__getordercreatorbynumberResponse(struct soap *soap, const char *tag, struct ns1__getordercreatorbynumberResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getordercreatorbynumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getordercreatorbynumberResponse, sizeof(struct ns1__getordercreatorbynumberResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getordercreatorbynumberResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getordercreatorbynumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getordercreatorbynumberResponse, SOAP_TYPE_ns1__getordercreatorbynumberResponse, sizeof(struct ns1__getordercreatorbynumberResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getordercreatorbynumberResponse * SOAP_FMAC2 soap_instantiate_ns1__getordercreatorbynumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getordercreatorbynumberResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getordercreatorbynumberResponse *p;
	size_t k = sizeof(struct ns1__getordercreatorbynumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getordercreatorbynumberResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getordercreatorbynumberResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getordercreatorbynumberResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getordercreatorbynumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getordercreatorbynumberResponse(struct soap *soap, const struct ns1__getordercreatorbynumberResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getordercreatorbynumberResponse(soap, tag ? tag : "ns1:getordercreatorbynumberResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getordercreatorbynumberResponse * SOAP_FMAC4 soap_get_ns1__getordercreatorbynumberResponse(struct soap *soap, struct ns1__getordercreatorbynumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getordercreatorbynumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__unCheckOut(struct soap *soap, struct ns1__unCheckOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->filePath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__unCheckOut(struct soap *soap, const struct ns1__unCheckOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->filePath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unCheckOut(struct soap *soap, const char *tag, int id, const struct ns1__unCheckOut *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unCheckOut), type))
		return soap->error;
	if (soap_out_string(soap, "filePath", -1, (char*const*)&a->filePath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__unCheckOut * SOAP_FMAC4 soap_in_ns1__unCheckOut(struct soap *soap, const char *tag, struct ns1__unCheckOut *a, const char *type)
{
	size_t soap_flag_filePath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__unCheckOut *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unCheckOut, sizeof(struct ns1__unCheckOut), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__unCheckOut(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filePath", (char**)&a->filePath, "xsd:string"))
				{	soap_flag_filePath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__unCheckOut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unCheckOut, SOAP_TYPE_ns1__unCheckOut, sizeof(struct ns1__unCheckOut), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__unCheckOut * SOAP_FMAC2 soap_instantiate_ns1__unCheckOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unCheckOut(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__unCheckOut *p;
	size_t k = sizeof(struct ns1__unCheckOut);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__unCheckOut);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__unCheckOut, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__unCheckOut location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__unCheckOut, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__unCheckOut(struct soap *soap, const struct ns1__unCheckOut *a, const char *tag, const char *type)
{
	if (soap_out_ns1__unCheckOut(soap, tag ? tag : "ns1:unCheckOut", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__unCheckOut * SOAP_FMAC4 soap_get_ns1__unCheckOut(struct soap *soap, struct ns1__unCheckOut *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unCheckOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__unCheckOutResponse(struct soap *soap, struct ns1__unCheckOutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__unCheckOutResponse(struct soap *soap, const struct ns1__unCheckOutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unCheckOutResponse(struct soap *soap, const char *tag, int id, const struct ns1__unCheckOutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unCheckOutResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__unCheckOutResponse * SOAP_FMAC4 soap_in_ns1__unCheckOutResponse(struct soap *soap, const char *tag, struct ns1__unCheckOutResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__unCheckOutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unCheckOutResponse, sizeof(struct ns1__unCheckOutResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__unCheckOutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__unCheckOutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unCheckOutResponse, SOAP_TYPE_ns1__unCheckOutResponse, sizeof(struct ns1__unCheckOutResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__unCheckOutResponse * SOAP_FMAC2 soap_instantiate_ns1__unCheckOutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unCheckOutResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__unCheckOutResponse *p;
	size_t k = sizeof(struct ns1__unCheckOutResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__unCheckOutResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__unCheckOutResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__unCheckOutResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__unCheckOutResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__unCheckOutResponse(struct soap *soap, const struct ns1__unCheckOutResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__unCheckOutResponse(soap, tag ? tag : "ns1:unCheckOutResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__unCheckOutResponse * SOAP_FMAC4 soap_get_ns1__unCheckOutResponse(struct soap *soap, struct ns1__unCheckOutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unCheckOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callProduct(struct soap *soap, struct ns1__callProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callProduct(struct soap *soap, const struct ns1__callProduct *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callProduct(struct soap *soap, const char *tag, int id, const struct ns1__callProduct *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callProduct), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callProduct * SOAP_FMAC4 soap_in_ns1__callProduct(struct soap *soap, const char *tag, struct ns1__callProduct *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callProduct *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callProduct, sizeof(struct ns1__callProduct), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callProduct(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__callProduct *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callProduct, SOAP_TYPE_ns1__callProduct, sizeof(struct ns1__callProduct), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callProduct * SOAP_FMAC2 soap_instantiate_ns1__callProduct(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callProduct(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callProduct *p;
	size_t k = sizeof(struct ns1__callProduct);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callProduct);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callProduct, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callProduct location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callProduct, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callProduct(struct soap *soap, const struct ns1__callProduct *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callProduct(soap, tag ? tag : "ns1:callProduct", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callProduct * SOAP_FMAC4 soap_get_ns1__callProduct(struct soap *soap, struct ns1__callProduct *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callProduct(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callProductResponse(struct soap *soap, struct ns1__callProductResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callProductResponse(struct soap *soap, const struct ns1__callProductResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callProductResponse(struct soap *soap, const char *tag, int id, const struct ns1__callProductResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callProductResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callProductResponse * SOAP_FMAC4 soap_in_ns1__callProductResponse(struct soap *soap, const char *tag, struct ns1__callProductResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callProductResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callProductResponse, sizeof(struct ns1__callProductResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callProductResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__callProductResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callProductResponse, SOAP_TYPE_ns1__callProductResponse, sizeof(struct ns1__callProductResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callProductResponse * SOAP_FMAC2 soap_instantiate_ns1__callProductResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callProductResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callProductResponse *p;
	size_t k = sizeof(struct ns1__callProductResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callProductResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callProductResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callProductResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callProductResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callProductResponse(struct soap *soap, const struct ns1__callProductResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callProductResponse(soap, tag ? tag : "ns1:callProductResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callProductResponse * SOAP_FMAC4 soap_get_ns1__callProductResponse(struct soap *soap, struct ns1__callProductResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callProductResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callCheckIn(struct soap *soap, struct ns1__callCheckIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->filePath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callCheckIn(struct soap *soap, const struct ns1__callCheckIn *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->filePath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callCheckIn(struct soap *soap, const char *tag, int id, const struct ns1__callCheckIn *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callCheckIn), type))
		return soap->error;
	if (soap_out_string(soap, "filePath", -1, (char*const*)&a->filePath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callCheckIn * SOAP_FMAC4 soap_in_ns1__callCheckIn(struct soap *soap, const char *tag, struct ns1__callCheckIn *a, const char *type)
{
	size_t soap_flag_filePath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callCheckIn *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callCheckIn, sizeof(struct ns1__callCheckIn), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callCheckIn(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filePath", (char**)&a->filePath, "xsd:string"))
				{	soap_flag_filePath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__callCheckIn *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callCheckIn, SOAP_TYPE_ns1__callCheckIn, sizeof(struct ns1__callCheckIn), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callCheckIn * SOAP_FMAC2 soap_instantiate_ns1__callCheckIn(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callCheckIn(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callCheckIn *p;
	size_t k = sizeof(struct ns1__callCheckIn);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callCheckIn);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callCheckIn, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callCheckIn location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callCheckIn, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callCheckIn(struct soap *soap, const struct ns1__callCheckIn *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callCheckIn(soap, tag ? tag : "ns1:callCheckIn", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callCheckIn * SOAP_FMAC4 soap_get_ns1__callCheckIn(struct soap *soap, struct ns1__callCheckIn *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callCheckIn(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callCheckInResponse(struct soap *soap, struct ns1__callCheckInResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callCheckInResponse(struct soap *soap, const struct ns1__callCheckInResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callCheckInResponse(struct soap *soap, const char *tag, int id, const struct ns1__callCheckInResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callCheckInResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callCheckInResponse * SOAP_FMAC4 soap_in_ns1__callCheckInResponse(struct soap *soap, const char *tag, struct ns1__callCheckInResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callCheckInResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callCheckInResponse, sizeof(struct ns1__callCheckInResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callCheckInResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__callCheckInResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callCheckInResponse, SOAP_TYPE_ns1__callCheckInResponse, sizeof(struct ns1__callCheckInResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callCheckInResponse * SOAP_FMAC2 soap_instantiate_ns1__callCheckInResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callCheckInResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callCheckInResponse *p;
	size_t k = sizeof(struct ns1__callCheckInResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callCheckInResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callCheckInResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callCheckInResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callCheckInResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callCheckInResponse(struct soap *soap, const struct ns1__callCheckInResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callCheckInResponse(soap, tag ? tag : "ns1:callCheckInResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callCheckInResponse * SOAP_FMAC4 soap_get_ns1__callCheckInResponse(struct soap *soap, struct ns1__callCheckInResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callCheckInResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callCheckOut(struct soap *soap, struct ns1__callCheckOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->partNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callCheckOut(struct soap *soap, const struct ns1__callCheckOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->partNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callCheckOut(struct soap *soap, const char *tag, int id, const struct ns1__callCheckOut *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callCheckOut), type))
		return soap->error;
	if (soap_out_string(soap, "partNumber", -1, (char*const*)&a->partNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callCheckOut * SOAP_FMAC4 soap_in_ns1__callCheckOut(struct soap *soap, const char *tag, struct ns1__callCheckOut *a, const char *type)
{
	size_t soap_flag_partNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callCheckOut *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callCheckOut, sizeof(struct ns1__callCheckOut), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callCheckOut(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_partNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "partNumber", (char**)&a->partNumber, "xsd:string"))
				{	soap_flag_partNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__callCheckOut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callCheckOut, SOAP_TYPE_ns1__callCheckOut, sizeof(struct ns1__callCheckOut), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callCheckOut * SOAP_FMAC2 soap_instantiate_ns1__callCheckOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callCheckOut(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callCheckOut *p;
	size_t k = sizeof(struct ns1__callCheckOut);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callCheckOut);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callCheckOut, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callCheckOut location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callCheckOut, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callCheckOut(struct soap *soap, const struct ns1__callCheckOut *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callCheckOut(soap, tag ? tag : "ns1:callCheckOut", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callCheckOut * SOAP_FMAC4 soap_get_ns1__callCheckOut(struct soap *soap, struct ns1__callCheckOut *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callCheckOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callCheckOutResponse(struct soap *soap, struct ns1__callCheckOutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callCheckOutResponse(struct soap *soap, const struct ns1__callCheckOutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callCheckOutResponse(struct soap *soap, const char *tag, int id, const struct ns1__callCheckOutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callCheckOutResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callCheckOutResponse * SOAP_FMAC4 soap_in_ns1__callCheckOutResponse(struct soap *soap, const char *tag, struct ns1__callCheckOutResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callCheckOutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callCheckOutResponse, sizeof(struct ns1__callCheckOutResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callCheckOutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__callCheckOutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callCheckOutResponse, SOAP_TYPE_ns1__callCheckOutResponse, sizeof(struct ns1__callCheckOutResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callCheckOutResponse * SOAP_FMAC2 soap_instantiate_ns1__callCheckOutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callCheckOutResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callCheckOutResponse *p;
	size_t k = sizeof(struct ns1__callCheckOutResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callCheckOutResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callCheckOutResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callCheckOutResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callCheckOutResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callCheckOutResponse(struct soap *soap, const struct ns1__callCheckOutResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callCheckOutResponse(soap, tag ? tag : "ns1:callCheckOutResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callCheckOutResponse * SOAP_FMAC4 soap_get_ns1__callCheckOutResponse(struct soap *soap, struct ns1__callCheckOutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callCheckOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callCheckUser(struct soap *soap, struct ns1__callCheckUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->filePath);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callCheckUser(struct soap *soap, const struct ns1__callCheckUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->filePath);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callCheckUser(struct soap *soap, const char *tag, int id, const struct ns1__callCheckUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callCheckUser), type))
		return soap->error;
	if (soap_out_string(soap, "filePath", -1, (char*const*)&a->filePath, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callCheckUser * SOAP_FMAC4 soap_in_ns1__callCheckUser(struct soap *soap, const char *tag, struct ns1__callCheckUser *a, const char *type)
{
	size_t soap_flag_filePath = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callCheckUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callCheckUser, sizeof(struct ns1__callCheckUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callCheckUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filePath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "filePath", (char**)&a->filePath, "xsd:string"))
				{	soap_flag_filePath--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__callCheckUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callCheckUser, SOAP_TYPE_ns1__callCheckUser, sizeof(struct ns1__callCheckUser), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callCheckUser * SOAP_FMAC2 soap_instantiate_ns1__callCheckUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callCheckUser(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callCheckUser *p;
	size_t k = sizeof(struct ns1__callCheckUser);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callCheckUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callCheckUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callCheckUser location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callCheckUser, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callCheckUser(struct soap *soap, const struct ns1__callCheckUser *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callCheckUser(soap, tag ? tag : "ns1:callCheckUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callCheckUser * SOAP_FMAC4 soap_get_ns1__callCheckUser(struct soap *soap, struct ns1__callCheckUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callCheckUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callCheckUserResponse(struct soap *soap, struct ns1__callCheckUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callCheckUserResponse(struct soap *soap, const struct ns1__callCheckUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callCheckUserResponse(struct soap *soap, const char *tag, int id, const struct ns1__callCheckUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callCheckUserResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callCheckUserResponse * SOAP_FMAC4 soap_in_ns1__callCheckUserResponse(struct soap *soap, const char *tag, struct ns1__callCheckUserResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callCheckUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callCheckUserResponse, sizeof(struct ns1__callCheckUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callCheckUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__callCheckUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callCheckUserResponse, SOAP_TYPE_ns1__callCheckUserResponse, sizeof(struct ns1__callCheckUserResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callCheckUserResponse * SOAP_FMAC2 soap_instantiate_ns1__callCheckUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callCheckUserResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callCheckUserResponse *p;
	size_t k = sizeof(struct ns1__callCheckUserResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callCheckUserResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callCheckUserResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callCheckUserResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callCheckUserResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callCheckUserResponse(struct soap *soap, const struct ns1__callCheckUserResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callCheckUserResponse(soap, tag ? tag : "ns1:callCheckUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callCheckUserResponse * SOAP_FMAC4 soap_get_ns1__callCheckUserResponse(struct soap *soap, struct ns1__callCheckUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callCheckUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callSearch(struct soap *soap, struct ns1__callSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->partNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callSearch(struct soap *soap, const struct ns1__callSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->partNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callSearch(struct soap *soap, const char *tag, int id, const struct ns1__callSearch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callSearch), type))
		return soap->error;
	if (soap_out_string(soap, "partNumber", -1, (char*const*)&a->partNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callSearch * SOAP_FMAC4 soap_in_ns1__callSearch(struct soap *soap, const char *tag, struct ns1__callSearch *a, const char *type)
{
	size_t soap_flag_partNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callSearch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callSearch, sizeof(struct ns1__callSearch), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callSearch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_partNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "partNumber", (char**)&a->partNumber, "xsd:string"))
				{	soap_flag_partNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__callSearch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callSearch, SOAP_TYPE_ns1__callSearch, sizeof(struct ns1__callSearch), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callSearch * SOAP_FMAC2 soap_instantiate_ns1__callSearch(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callSearch(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callSearch *p;
	size_t k = sizeof(struct ns1__callSearch);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callSearch);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callSearch, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callSearch location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callSearch, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callSearch(struct soap *soap, const struct ns1__callSearch *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callSearch(soap, tag ? tag : "ns1:callSearch", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callSearch * SOAP_FMAC4 soap_get_ns1__callSearch(struct soap *soap, struct ns1__callSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__callSearchResponse(struct soap *soap, struct ns1__callSearchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__callSearchResponse(struct soap *soap, const struct ns1__callSearchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__callSearchResponse(struct soap *soap, const char *tag, int id, const struct ns1__callSearchResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__callSearchResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__callSearchResponse * SOAP_FMAC4 soap_in_ns1__callSearchResponse(struct soap *soap, const char *tag, struct ns1__callSearchResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__callSearchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__callSearchResponse, sizeof(struct ns1__callSearchResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__callSearchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__callSearchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__callSearchResponse, SOAP_TYPE_ns1__callSearchResponse, sizeof(struct ns1__callSearchResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__callSearchResponse * SOAP_FMAC2 soap_instantiate_ns1__callSearchResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__callSearchResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__callSearchResponse *p;
	size_t k = sizeof(struct ns1__callSearchResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__callSearchResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__callSearchResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__callSearchResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__callSearchResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__callSearchResponse(struct soap *soap, const struct ns1__callSearchResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__callSearchResponse(soap, tag ? tag : "ns1:callSearchResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__callSearchResponse * SOAP_FMAC4 soap_get_ns1__callSearchResponse(struct soap *soap, struct ns1__callSearchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__callSearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolder(struct soap *soap, struct ns1__getFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->param);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolder(struct soap *soap, const struct ns1__getFolder *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->param);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolder(struct soap *soap, const char *tag, int id, const struct ns1__getFolder *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolder), type))
		return soap->error;
	if (soap_out_string(soap, "param", -1, (char*const*)&a->param, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolder * SOAP_FMAC4 soap_in_ns1__getFolder(struct soap *soap, const char *tag, struct ns1__getFolder *a, const char *type)
{
	size_t soap_flag_param = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolder *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolder, sizeof(struct ns1__getFolder), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolder(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_param && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "param", (char**)&a->param, "xsd:string"))
				{	soap_flag_param--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getFolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolder, SOAP_TYPE_ns1__getFolder, sizeof(struct ns1__getFolder), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getFolder * SOAP_FMAC2 soap_instantiate_ns1__getFolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolder(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getFolder *p;
	size_t k = sizeof(struct ns1__getFolder);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getFolder);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getFolder, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getFolder location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getFolder, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolder(struct soap *soap, const struct ns1__getFolder *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getFolder(soap, tag ? tag : "ns1:getFolder", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolder * SOAP_FMAC4 soap_get_ns1__getFolder(struct soap *soap, struct ns1__getFolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getFolderResponse(struct soap *soap, struct ns1__getFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getFolderResponse(struct soap *soap, const struct ns1__getFolderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getFolderResponse(struct soap *soap, const char *tag, int id, const struct ns1__getFolderResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getFolderResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getFolderResponse * SOAP_FMAC4 soap_in_ns1__getFolderResponse(struct soap *soap, const char *tag, struct ns1__getFolderResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getFolderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getFolderResponse, sizeof(struct ns1__getFolderResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getFolderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getFolderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getFolderResponse, SOAP_TYPE_ns1__getFolderResponse, sizeof(struct ns1__getFolderResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getFolderResponse * SOAP_FMAC2 soap_instantiate_ns1__getFolderResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getFolderResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getFolderResponse *p;
	size_t k = sizeof(struct ns1__getFolderResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getFolderResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getFolderResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getFolderResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getFolderResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getFolderResponse(struct soap *soap, const struct ns1__getFolderResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getFolderResponse(soap, tag ? tag : "ns1:getFolderResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getFolderResponse * SOAP_FMAC4 soap_get_ns1__getFolderResponse(struct soap *soap, struct ns1__getFolderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getFolderResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getZip(struct soap *soap, struct ns1__getZip *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->partNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getZip(struct soap *soap, const struct ns1__getZip *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->partNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getZip(struct soap *soap, const char *tag, int id, const struct ns1__getZip *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getZip), type))
		return soap->error;
	if (soap_out_string(soap, "partNumber", -1, (char*const*)&a->partNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getZip * SOAP_FMAC4 soap_in_ns1__getZip(struct soap *soap, const char *tag, struct ns1__getZip *a, const char *type)
{
	size_t soap_flag_partNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getZip *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getZip, sizeof(struct ns1__getZip), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getZip(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_partNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "partNumber", (char**)&a->partNumber, "xsd:string"))
				{	soap_flag_partNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getZip *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getZip, SOAP_TYPE_ns1__getZip, sizeof(struct ns1__getZip), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getZip * SOAP_FMAC2 soap_instantiate_ns1__getZip(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getZip(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getZip *p;
	size_t k = sizeof(struct ns1__getZip);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getZip);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getZip, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getZip location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getZip, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getZip(struct soap *soap, const struct ns1__getZip *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getZip(soap, tag ? tag : "ns1:getZip", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getZip * SOAP_FMAC4 soap_get_ns1__getZip(struct soap *soap, struct ns1__getZip *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getZip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getZipResponse(struct soap *soap, struct ns1__getZipResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getZipResponse(struct soap *soap, const struct ns1__getZipResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getZipResponse(struct soap *soap, const char *tag, int id, const struct ns1__getZipResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getZipResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getZipResponse * SOAP_FMAC4 soap_in_ns1__getZipResponse(struct soap *soap, const char *tag, struct ns1__getZipResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getZipResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getZipResponse, sizeof(struct ns1__getZipResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getZipResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getZipResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getZipResponse, SOAP_TYPE_ns1__getZipResponse, sizeof(struct ns1__getZipResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getZipResponse * SOAP_FMAC2 soap_instantiate_ns1__getZipResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getZipResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getZipResponse *p;
	size_t k = sizeof(struct ns1__getZipResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getZipResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getZipResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getZipResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getZipResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getZipResponse(struct soap *soap, const struct ns1__getZipResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getZipResponse(soap, tag ? tag : "ns1:getZipResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getZipResponse * SOAP_FMAC4 soap_get_ns1__getZipResponse(struct soap *soap, struct ns1__getZipResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getZipResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__reviseAndCheckOut(struct soap *soap, struct ns1__reviseAndCheckOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->partNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__reviseAndCheckOut(struct soap *soap, const struct ns1__reviseAndCheckOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->partNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reviseAndCheckOut(struct soap *soap, const char *tag, int id, const struct ns1__reviseAndCheckOut *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__reviseAndCheckOut), type))
		return soap->error;
	if (soap_out_string(soap, "partNumber", -1, (char*const*)&a->partNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__reviseAndCheckOut * SOAP_FMAC4 soap_in_ns1__reviseAndCheckOut(struct soap *soap, const char *tag, struct ns1__reviseAndCheckOut *a, const char *type)
{
	size_t soap_flag_partNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__reviseAndCheckOut *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reviseAndCheckOut, sizeof(struct ns1__reviseAndCheckOut), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__reviseAndCheckOut(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_partNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "partNumber", (char**)&a->partNumber, "xsd:string"))
				{	soap_flag_partNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__reviseAndCheckOut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__reviseAndCheckOut, SOAP_TYPE_ns1__reviseAndCheckOut, sizeof(struct ns1__reviseAndCheckOut), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__reviseAndCheckOut * SOAP_FMAC2 soap_instantiate_ns1__reviseAndCheckOut(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__reviseAndCheckOut(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__reviseAndCheckOut *p;
	size_t k = sizeof(struct ns1__reviseAndCheckOut);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__reviseAndCheckOut);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__reviseAndCheckOut, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__reviseAndCheckOut location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__reviseAndCheckOut, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__reviseAndCheckOut(struct soap *soap, const struct ns1__reviseAndCheckOut *a, const char *tag, const char *type)
{
	if (soap_out_ns1__reviseAndCheckOut(soap, tag ? tag : "ns1:reviseAndCheckOut", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__reviseAndCheckOut * SOAP_FMAC4 soap_get_ns1__reviseAndCheckOut(struct soap *soap, struct ns1__reviseAndCheckOut *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__reviseAndCheckOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__reviseAndCheckOutResponse(struct soap *soap, struct ns1__reviseAndCheckOutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__reviseAndCheckOutResponse(struct soap *soap, const struct ns1__reviseAndCheckOutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__reviseAndCheckOutResponse(struct soap *soap, const char *tag, int id, const struct ns1__reviseAndCheckOutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__reviseAndCheckOutResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__reviseAndCheckOutResponse * SOAP_FMAC4 soap_in_ns1__reviseAndCheckOutResponse(struct soap *soap, const char *tag, struct ns1__reviseAndCheckOutResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__reviseAndCheckOutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__reviseAndCheckOutResponse, sizeof(struct ns1__reviseAndCheckOutResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__reviseAndCheckOutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__reviseAndCheckOutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__reviseAndCheckOutResponse, SOAP_TYPE_ns1__reviseAndCheckOutResponse, sizeof(struct ns1__reviseAndCheckOutResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__reviseAndCheckOutResponse * SOAP_FMAC2 soap_instantiate_ns1__reviseAndCheckOutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__reviseAndCheckOutResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__reviseAndCheckOutResponse *p;
	size_t k = sizeof(struct ns1__reviseAndCheckOutResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__reviseAndCheckOutResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__reviseAndCheckOutResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__reviseAndCheckOutResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__reviseAndCheckOutResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__reviseAndCheckOutResponse(struct soap *soap, const struct ns1__reviseAndCheckOutResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__reviseAndCheckOutResponse(soap, tag ? tag : "ns1:reviseAndCheckOutResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__reviseAndCheckOutResponse * SOAP_FMAC4 soap_get_ns1__reviseAndCheckOutResponse(struct soap *soap, struct ns1__reviseAndCheckOutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__reviseAndCheckOutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__tipicalCraftSelector(struct soap *soap, struct ns1__tipicalCraftSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__tipicalCraftSelector(struct soap *soap, const struct ns1__tipicalCraftSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__tipicalCraftSelector(struct soap *soap, const char *tag, int id, const struct ns1__tipicalCraftSelector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__tipicalCraftSelector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__tipicalCraftSelector * SOAP_FMAC4 soap_in_ns1__tipicalCraftSelector(struct soap *soap, const char *tag, struct ns1__tipicalCraftSelector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__tipicalCraftSelector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__tipicalCraftSelector, sizeof(struct ns1__tipicalCraftSelector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__tipicalCraftSelector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__tipicalCraftSelector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__tipicalCraftSelector, SOAP_TYPE_ns1__tipicalCraftSelector, sizeof(struct ns1__tipicalCraftSelector), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__tipicalCraftSelector * SOAP_FMAC2 soap_instantiate_ns1__tipicalCraftSelector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__tipicalCraftSelector(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__tipicalCraftSelector *p;
	size_t k = sizeof(struct ns1__tipicalCraftSelector);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__tipicalCraftSelector);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__tipicalCraftSelector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__tipicalCraftSelector location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__tipicalCraftSelector, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__tipicalCraftSelector(struct soap *soap, const struct ns1__tipicalCraftSelector *a, const char *tag, const char *type)
{
	if (soap_out_ns1__tipicalCraftSelector(soap, tag ? tag : "ns1:tipicalCraftSelector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__tipicalCraftSelector * SOAP_FMAC4 soap_get_ns1__tipicalCraftSelector(struct soap *soap, struct ns1__tipicalCraftSelector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__tipicalCraftSelector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__tipicalCraftSelectorResponse(struct soap *soap, struct ns1__tipicalCraftSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__tipicalCraftSelectorResponse(struct soap *soap, const struct ns1__tipicalCraftSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__tipicalCraftSelectorResponse(struct soap *soap, const char *tag, int id, const struct ns1__tipicalCraftSelectorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__tipicalCraftSelectorResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__tipicalCraftSelectorResponse * SOAP_FMAC4 soap_in_ns1__tipicalCraftSelectorResponse(struct soap *soap, const char *tag, struct ns1__tipicalCraftSelectorResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__tipicalCraftSelectorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__tipicalCraftSelectorResponse, sizeof(struct ns1__tipicalCraftSelectorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__tipicalCraftSelectorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__tipicalCraftSelectorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__tipicalCraftSelectorResponse, SOAP_TYPE_ns1__tipicalCraftSelectorResponse, sizeof(struct ns1__tipicalCraftSelectorResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__tipicalCraftSelectorResponse * SOAP_FMAC2 soap_instantiate_ns1__tipicalCraftSelectorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__tipicalCraftSelectorResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__tipicalCraftSelectorResponse *p;
	size_t k = sizeof(struct ns1__tipicalCraftSelectorResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__tipicalCraftSelectorResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__tipicalCraftSelectorResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__tipicalCraftSelectorResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__tipicalCraftSelectorResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__tipicalCraftSelectorResponse(struct soap *soap, const struct ns1__tipicalCraftSelectorResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__tipicalCraftSelectorResponse(soap, tag ? tag : "ns1:tipicalCraftSelectorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__tipicalCraftSelectorResponse * SOAP_FMAC4 soap_get_ns1__tipicalCraftSelectorResponse(struct soap *soap, struct ns1__tipicalCraftSelectorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__tipicalCraftSelectorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getorderbynumber(struct soap *soap, struct ns1__getorderbynumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getorderbynumber(struct soap *soap, const struct ns1__getorderbynumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getorderbynumber(struct soap *soap, const char *tag, int id, const struct ns1__getorderbynumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getorderbynumber), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getorderbynumber * SOAP_FMAC4 soap_in_ns1__getorderbynumber(struct soap *soap, const char *tag, struct ns1__getorderbynumber *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getorderbynumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getorderbynumber, sizeof(struct ns1__getorderbynumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getorderbynumber(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getorderbynumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getorderbynumber, SOAP_TYPE_ns1__getorderbynumber, sizeof(struct ns1__getorderbynumber), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getorderbynumber * SOAP_FMAC2 soap_instantiate_ns1__getorderbynumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getorderbynumber(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getorderbynumber *p;
	size_t k = sizeof(struct ns1__getorderbynumber);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getorderbynumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getorderbynumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getorderbynumber location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getorderbynumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getorderbynumber(struct soap *soap, const struct ns1__getorderbynumber *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getorderbynumber(soap, tag ? tag : "ns1:getorderbynumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getorderbynumber * SOAP_FMAC4 soap_get_ns1__getorderbynumber(struct soap *soap, struct ns1__getorderbynumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getorderbynumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getorderbynumberResponse(struct soap *soap, struct ns1__getorderbynumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getorderbynumberResponse(struct soap *soap, const struct ns1__getorderbynumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getorderbynumberResponse(struct soap *soap, const char *tag, int id, const struct ns1__getorderbynumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getorderbynumberResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getorderbynumberResponse * SOAP_FMAC4 soap_in_ns1__getorderbynumberResponse(struct soap *soap, const char *tag, struct ns1__getorderbynumberResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getorderbynumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getorderbynumberResponse, sizeof(struct ns1__getorderbynumberResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getorderbynumberResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getorderbynumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getorderbynumberResponse, SOAP_TYPE_ns1__getorderbynumberResponse, sizeof(struct ns1__getorderbynumberResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getorderbynumberResponse * SOAP_FMAC2 soap_instantiate_ns1__getorderbynumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getorderbynumberResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getorderbynumberResponse *p;
	size_t k = sizeof(struct ns1__getorderbynumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getorderbynumberResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getorderbynumberResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getorderbynumberResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getorderbynumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getorderbynumberResponse(struct soap *soap, const struct ns1__getorderbynumberResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getorderbynumberResponse(soap, tag ? tag : "ns1:getorderbynumberResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getorderbynumberResponse * SOAP_FMAC4 soap_get_ns1__getorderbynumberResponse(struct soap *soap, struct ns1__getorderbynumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getorderbynumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__lingZuJianSelector(struct soap *soap, struct ns1__lingZuJianSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__lingZuJianSelector(struct soap *soap, const struct ns1__lingZuJianSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lingZuJianSelector(struct soap *soap, const char *tag, int id, const struct ns1__lingZuJianSelector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lingZuJianSelector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__lingZuJianSelector * SOAP_FMAC4 soap_in_ns1__lingZuJianSelector(struct soap *soap, const char *tag, struct ns1__lingZuJianSelector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__lingZuJianSelector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lingZuJianSelector, sizeof(struct ns1__lingZuJianSelector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__lingZuJianSelector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__lingZuJianSelector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lingZuJianSelector, SOAP_TYPE_ns1__lingZuJianSelector, sizeof(struct ns1__lingZuJianSelector), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__lingZuJianSelector * SOAP_FMAC2 soap_instantiate_ns1__lingZuJianSelector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lingZuJianSelector(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__lingZuJianSelector *p;
	size_t k = sizeof(struct ns1__lingZuJianSelector);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__lingZuJianSelector);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__lingZuJianSelector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__lingZuJianSelector location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__lingZuJianSelector, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__lingZuJianSelector(struct soap *soap, const struct ns1__lingZuJianSelector *a, const char *tag, const char *type)
{
	if (soap_out_ns1__lingZuJianSelector(soap, tag ? tag : "ns1:lingZuJianSelector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__lingZuJianSelector * SOAP_FMAC4 soap_get_ns1__lingZuJianSelector(struct soap *soap, struct ns1__lingZuJianSelector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lingZuJianSelector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__lingZuJianSelectorResponse(struct soap *soap, struct ns1__lingZuJianSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__lingZuJianSelectorResponse(struct soap *soap, const struct ns1__lingZuJianSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__lingZuJianSelectorResponse(struct soap *soap, const char *tag, int id, const struct ns1__lingZuJianSelectorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__lingZuJianSelectorResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__lingZuJianSelectorResponse * SOAP_FMAC4 soap_in_ns1__lingZuJianSelectorResponse(struct soap *soap, const char *tag, struct ns1__lingZuJianSelectorResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__lingZuJianSelectorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__lingZuJianSelectorResponse, sizeof(struct ns1__lingZuJianSelectorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__lingZuJianSelectorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__lingZuJianSelectorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__lingZuJianSelectorResponse, SOAP_TYPE_ns1__lingZuJianSelectorResponse, sizeof(struct ns1__lingZuJianSelectorResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__lingZuJianSelectorResponse * SOAP_FMAC2 soap_instantiate_ns1__lingZuJianSelectorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__lingZuJianSelectorResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__lingZuJianSelectorResponse *p;
	size_t k = sizeof(struct ns1__lingZuJianSelectorResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__lingZuJianSelectorResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__lingZuJianSelectorResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__lingZuJianSelectorResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__lingZuJianSelectorResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__lingZuJianSelectorResponse(struct soap *soap, const struct ns1__lingZuJianSelectorResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__lingZuJianSelectorResponse(soap, tag ? tag : "ns1:lingZuJianSelectorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__lingZuJianSelectorResponse * SOAP_FMAC4 soap_get_ns1__lingZuJianSelectorResponse(struct soap *soap, struct ns1__lingZuJianSelectorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__lingZuJianSelectorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sheBeiSelector(struct soap *soap, struct ns1__sheBeiSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sheBeiSelector(struct soap *soap, const struct ns1__sheBeiSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sheBeiSelector(struct soap *soap, const char *tag, int id, const struct ns1__sheBeiSelector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sheBeiSelector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sheBeiSelector * SOAP_FMAC4 soap_in_ns1__sheBeiSelector(struct soap *soap, const char *tag, struct ns1__sheBeiSelector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sheBeiSelector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sheBeiSelector, sizeof(struct ns1__sheBeiSelector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__sheBeiSelector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__sheBeiSelector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sheBeiSelector, SOAP_TYPE_ns1__sheBeiSelector, sizeof(struct ns1__sheBeiSelector), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__sheBeiSelector * SOAP_FMAC2 soap_instantiate_ns1__sheBeiSelector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sheBeiSelector(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__sheBeiSelector *p;
	size_t k = sizeof(struct ns1__sheBeiSelector);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__sheBeiSelector);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__sheBeiSelector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__sheBeiSelector location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__sheBeiSelector, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sheBeiSelector(struct soap *soap, const struct ns1__sheBeiSelector *a, const char *tag, const char *type)
{
	if (soap_out_ns1__sheBeiSelector(soap, tag ? tag : "ns1:sheBeiSelector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sheBeiSelector * SOAP_FMAC4 soap_get_ns1__sheBeiSelector(struct soap *soap, struct ns1__sheBeiSelector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sheBeiSelector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__sheBeiSelectorResponse(struct soap *soap, struct ns1__sheBeiSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__sheBeiSelectorResponse(struct soap *soap, const struct ns1__sheBeiSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sheBeiSelectorResponse(struct soap *soap, const char *tag, int id, const struct ns1__sheBeiSelectorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sheBeiSelectorResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__sheBeiSelectorResponse * SOAP_FMAC4 soap_in_ns1__sheBeiSelectorResponse(struct soap *soap, const char *tag, struct ns1__sheBeiSelectorResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__sheBeiSelectorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sheBeiSelectorResponse, sizeof(struct ns1__sheBeiSelectorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__sheBeiSelectorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__sheBeiSelectorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sheBeiSelectorResponse, SOAP_TYPE_ns1__sheBeiSelectorResponse, sizeof(struct ns1__sheBeiSelectorResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__sheBeiSelectorResponse * SOAP_FMAC2 soap_instantiate_ns1__sheBeiSelectorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sheBeiSelectorResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__sheBeiSelectorResponse *p;
	size_t k = sizeof(struct ns1__sheBeiSelectorResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__sheBeiSelectorResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__sheBeiSelectorResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__sheBeiSelectorResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__sheBeiSelectorResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__sheBeiSelectorResponse(struct soap *soap, const struct ns1__sheBeiSelectorResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__sheBeiSelectorResponse(soap, tag ? tag : "ns1:sheBeiSelectorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__sheBeiSelectorResponse * SOAP_FMAC4 soap_get_ns1__sheBeiSelectorResponse(struct soap *soap, struct ns1__sheBeiSelectorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sheBeiSelectorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__loadAssemblePartsByPartNumber(struct soap *soap, struct ns1__loadAssemblePartsByPartNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__loadAssemblePartsByPartNumber(struct soap *soap, const struct ns1__loadAssemblePartsByPartNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loadAssemblePartsByPartNumber(struct soap *soap, const char *tag, int id, const struct ns1__loadAssemblePartsByPartNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loadAssemblePartsByPartNumber), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__loadAssemblePartsByPartNumber * SOAP_FMAC4 soap_in_ns1__loadAssemblePartsByPartNumber(struct soap *soap, const char *tag, struct ns1__loadAssemblePartsByPartNumber *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__loadAssemblePartsByPartNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loadAssemblePartsByPartNumber, sizeof(struct ns1__loadAssemblePartsByPartNumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__loadAssemblePartsByPartNumber(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__loadAssemblePartsByPartNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loadAssemblePartsByPartNumber, SOAP_TYPE_ns1__loadAssemblePartsByPartNumber, sizeof(struct ns1__loadAssemblePartsByPartNumber), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__loadAssemblePartsByPartNumber * SOAP_FMAC2 soap_instantiate_ns1__loadAssemblePartsByPartNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loadAssemblePartsByPartNumber(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__loadAssemblePartsByPartNumber *p;
	size_t k = sizeof(struct ns1__loadAssemblePartsByPartNumber);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__loadAssemblePartsByPartNumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__loadAssemblePartsByPartNumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__loadAssemblePartsByPartNumber location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__loadAssemblePartsByPartNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__loadAssemblePartsByPartNumber(struct soap *soap, const struct ns1__loadAssemblePartsByPartNumber *a, const char *tag, const char *type)
{
	if (soap_out_ns1__loadAssemblePartsByPartNumber(soap, tag ? tag : "ns1:loadAssemblePartsByPartNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__loadAssemblePartsByPartNumber * SOAP_FMAC4 soap_get_ns1__loadAssemblePartsByPartNumber(struct soap *soap, struct ns1__loadAssemblePartsByPartNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loadAssemblePartsByPartNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__loadAssemblePartsByPartNumberResponse(struct soap *soap, struct ns1__loadAssemblePartsByPartNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__loadAssemblePartsByPartNumberResponse(struct soap *soap, const struct ns1__loadAssemblePartsByPartNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__loadAssemblePartsByPartNumberResponse(struct soap *soap, const char *tag, int id, const struct ns1__loadAssemblePartsByPartNumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__loadAssemblePartsByPartNumberResponse * SOAP_FMAC4 soap_in_ns1__loadAssemblePartsByPartNumberResponse(struct soap *soap, const char *tag, struct ns1__loadAssemblePartsByPartNumberResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__loadAssemblePartsByPartNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse, sizeof(struct ns1__loadAssemblePartsByPartNumberResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__loadAssemblePartsByPartNumberResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__loadAssemblePartsByPartNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse, SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse, sizeof(struct ns1__loadAssemblePartsByPartNumberResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__loadAssemblePartsByPartNumberResponse * SOAP_FMAC2 soap_instantiate_ns1__loadAssemblePartsByPartNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__loadAssemblePartsByPartNumberResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__loadAssemblePartsByPartNumberResponse *p;
	size_t k = sizeof(struct ns1__loadAssemblePartsByPartNumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__loadAssemblePartsByPartNumberResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__loadAssemblePartsByPartNumberResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__loadAssemblePartsByPartNumberResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__loadAssemblePartsByPartNumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__loadAssemblePartsByPartNumberResponse(struct soap *soap, const struct ns1__loadAssemblePartsByPartNumberResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__loadAssemblePartsByPartNumberResponse(soap, tag ? tag : "ns1:loadAssemblePartsByPartNumberResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__loadAssemblePartsByPartNumberResponse * SOAP_FMAC4 soap_get_ns1__loadAssemblePartsByPartNumberResponse(struct soap *soap, struct ns1__loadAssemblePartsByPartNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__loadAssemblePartsByPartNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__gongZhuangSelector(struct soap *soap, struct ns1__gongZhuangSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__gongZhuangSelector(struct soap *soap, const struct ns1__gongZhuangSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gongZhuangSelector(struct soap *soap, const char *tag, int id, const struct ns1__gongZhuangSelector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gongZhuangSelector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__gongZhuangSelector * SOAP_FMAC4 soap_in_ns1__gongZhuangSelector(struct soap *soap, const char *tag, struct ns1__gongZhuangSelector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__gongZhuangSelector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gongZhuangSelector, sizeof(struct ns1__gongZhuangSelector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__gongZhuangSelector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__gongZhuangSelector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gongZhuangSelector, SOAP_TYPE_ns1__gongZhuangSelector, sizeof(struct ns1__gongZhuangSelector), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__gongZhuangSelector * SOAP_FMAC2 soap_instantiate_ns1__gongZhuangSelector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gongZhuangSelector(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__gongZhuangSelector *p;
	size_t k = sizeof(struct ns1__gongZhuangSelector);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__gongZhuangSelector);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__gongZhuangSelector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__gongZhuangSelector location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__gongZhuangSelector, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__gongZhuangSelector(struct soap *soap, const struct ns1__gongZhuangSelector *a, const char *tag, const char *type)
{
	if (soap_out_ns1__gongZhuangSelector(soap, tag ? tag : "ns1:gongZhuangSelector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__gongZhuangSelector * SOAP_FMAC4 soap_get_ns1__gongZhuangSelector(struct soap *soap, struct ns1__gongZhuangSelector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gongZhuangSelector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__gongZhuangSelectorResponse(struct soap *soap, struct ns1__gongZhuangSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__gongZhuangSelectorResponse(struct soap *soap, const struct ns1__gongZhuangSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gongZhuangSelectorResponse(struct soap *soap, const char *tag, int id, const struct ns1__gongZhuangSelectorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gongZhuangSelectorResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__gongZhuangSelectorResponse * SOAP_FMAC4 soap_in_ns1__gongZhuangSelectorResponse(struct soap *soap, const char *tag, struct ns1__gongZhuangSelectorResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__gongZhuangSelectorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gongZhuangSelectorResponse, sizeof(struct ns1__gongZhuangSelectorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__gongZhuangSelectorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__gongZhuangSelectorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gongZhuangSelectorResponse, SOAP_TYPE_ns1__gongZhuangSelectorResponse, sizeof(struct ns1__gongZhuangSelectorResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__gongZhuangSelectorResponse * SOAP_FMAC2 soap_instantiate_ns1__gongZhuangSelectorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gongZhuangSelectorResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__gongZhuangSelectorResponse *p;
	size_t k = sizeof(struct ns1__gongZhuangSelectorResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__gongZhuangSelectorResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__gongZhuangSelectorResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__gongZhuangSelectorResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__gongZhuangSelectorResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__gongZhuangSelectorResponse(struct soap *soap, const struct ns1__gongZhuangSelectorResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__gongZhuangSelectorResponse(soap, tag ? tag : "ns1:gongZhuangSelectorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__gongZhuangSelectorResponse * SOAP_FMAC4 soap_get_ns1__gongZhuangSelectorResponse(struct soap *soap, struct ns1__gongZhuangSelectorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gongZhuangSelectorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__gongliangjiajuSelector(struct soap *soap, struct ns1__gongliangjiajuSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__gongliangjiajuSelector(struct soap *soap, const struct ns1__gongliangjiajuSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gongliangjiajuSelector(struct soap *soap, const char *tag, int id, const struct ns1__gongliangjiajuSelector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gongliangjiajuSelector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__gongliangjiajuSelector * SOAP_FMAC4 soap_in_ns1__gongliangjiajuSelector(struct soap *soap, const char *tag, struct ns1__gongliangjiajuSelector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__gongliangjiajuSelector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gongliangjiajuSelector, sizeof(struct ns1__gongliangjiajuSelector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__gongliangjiajuSelector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__gongliangjiajuSelector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gongliangjiajuSelector, SOAP_TYPE_ns1__gongliangjiajuSelector, sizeof(struct ns1__gongliangjiajuSelector), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__gongliangjiajuSelector * SOAP_FMAC2 soap_instantiate_ns1__gongliangjiajuSelector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gongliangjiajuSelector(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__gongliangjiajuSelector *p;
	size_t k = sizeof(struct ns1__gongliangjiajuSelector);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__gongliangjiajuSelector);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__gongliangjiajuSelector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__gongliangjiajuSelector location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__gongliangjiajuSelector, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__gongliangjiajuSelector(struct soap *soap, const struct ns1__gongliangjiajuSelector *a, const char *tag, const char *type)
{
	if (soap_out_ns1__gongliangjiajuSelector(soap, tag ? tag : "ns1:gongliangjiajuSelector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__gongliangjiajuSelector * SOAP_FMAC4 soap_get_ns1__gongliangjiajuSelector(struct soap *soap, struct ns1__gongliangjiajuSelector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gongliangjiajuSelector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__gongliangjiajuSelectorResponse(struct soap *soap, struct ns1__gongliangjiajuSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__gongliangjiajuSelectorResponse(struct soap *soap, const struct ns1__gongliangjiajuSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__gongliangjiajuSelectorResponse(struct soap *soap, const char *tag, int id, const struct ns1__gongliangjiajuSelectorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__gongliangjiajuSelectorResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__gongliangjiajuSelectorResponse * SOAP_FMAC4 soap_in_ns1__gongliangjiajuSelectorResponse(struct soap *soap, const char *tag, struct ns1__gongliangjiajuSelectorResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__gongliangjiajuSelectorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__gongliangjiajuSelectorResponse, sizeof(struct ns1__gongliangjiajuSelectorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__gongliangjiajuSelectorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__gongliangjiajuSelectorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__gongliangjiajuSelectorResponse, SOAP_TYPE_ns1__gongliangjiajuSelectorResponse, sizeof(struct ns1__gongliangjiajuSelectorResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__gongliangjiajuSelectorResponse * SOAP_FMAC2 soap_instantiate_ns1__gongliangjiajuSelectorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__gongliangjiajuSelectorResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__gongliangjiajuSelectorResponse *p;
	size_t k = sizeof(struct ns1__gongliangjiajuSelectorResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__gongliangjiajuSelectorResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__gongliangjiajuSelectorResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__gongliangjiajuSelectorResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__gongliangjiajuSelectorResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__gongliangjiajuSelectorResponse(struct soap *soap, const struct ns1__gongliangjiajuSelectorResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__gongliangjiajuSelectorResponse(soap, tag ? tag : "ns1:gongliangjiajuSelectorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__gongliangjiajuSelectorResponse * SOAP_FMAC4 soap_get_ns1__gongliangjiajuSelectorResponse(struct soap *soap, struct ns1__gongliangjiajuSelectorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__gongliangjiajuSelectorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fuZhuJianSelector(struct soap *soap, struct ns1__fuZhuJianSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fuZhuJianSelector(struct soap *soap, const struct ns1__fuZhuJianSelector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fuZhuJianSelector(struct soap *soap, const char *tag, int id, const struct ns1__fuZhuJianSelector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fuZhuJianSelector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fuZhuJianSelector * SOAP_FMAC4 soap_in_ns1__fuZhuJianSelector(struct soap *soap, const char *tag, struct ns1__fuZhuJianSelector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__fuZhuJianSelector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fuZhuJianSelector, sizeof(struct ns1__fuZhuJianSelector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__fuZhuJianSelector(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__fuZhuJianSelector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fuZhuJianSelector, SOAP_TYPE_ns1__fuZhuJianSelector, sizeof(struct ns1__fuZhuJianSelector), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__fuZhuJianSelector * SOAP_FMAC2 soap_instantiate_ns1__fuZhuJianSelector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__fuZhuJianSelector(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__fuZhuJianSelector *p;
	size_t k = sizeof(struct ns1__fuZhuJianSelector);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__fuZhuJianSelector);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__fuZhuJianSelector, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__fuZhuJianSelector location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__fuZhuJianSelector, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fuZhuJianSelector(struct soap *soap, const struct ns1__fuZhuJianSelector *a, const char *tag, const char *type)
{
	if (soap_out_ns1__fuZhuJianSelector(soap, tag ? tag : "ns1:fuZhuJianSelector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__fuZhuJianSelector * SOAP_FMAC4 soap_get_ns1__fuZhuJianSelector(struct soap *soap, struct ns1__fuZhuJianSelector *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fuZhuJianSelector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__fuZhuJianSelectorResponse(struct soap *soap, struct ns1__fuZhuJianSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__fuZhuJianSelectorResponse(struct soap *soap, const struct ns1__fuZhuJianSelectorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fuZhuJianSelectorResponse(struct soap *soap, const char *tag, int id, const struct ns1__fuZhuJianSelectorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fuZhuJianSelectorResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__fuZhuJianSelectorResponse * SOAP_FMAC4 soap_in_ns1__fuZhuJianSelectorResponse(struct soap *soap, const char *tag, struct ns1__fuZhuJianSelectorResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__fuZhuJianSelectorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fuZhuJianSelectorResponse, sizeof(struct ns1__fuZhuJianSelectorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__fuZhuJianSelectorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__fuZhuJianSelectorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fuZhuJianSelectorResponse, SOAP_TYPE_ns1__fuZhuJianSelectorResponse, sizeof(struct ns1__fuZhuJianSelectorResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__fuZhuJianSelectorResponse * SOAP_FMAC2 soap_instantiate_ns1__fuZhuJianSelectorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__fuZhuJianSelectorResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__fuZhuJianSelectorResponse *p;
	size_t k = sizeof(struct ns1__fuZhuJianSelectorResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__fuZhuJianSelectorResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__fuZhuJianSelectorResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__fuZhuJianSelectorResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__fuZhuJianSelectorResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__fuZhuJianSelectorResponse(struct soap *soap, const struct ns1__fuZhuJianSelectorResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__fuZhuJianSelectorResponse(soap, tag ? tag : "ns1:fuZhuJianSelectorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__fuZhuJianSelectorResponse * SOAP_FMAC4 soap_get_ns1__fuZhuJianSelectorResponse(struct soap *soap, struct ns1__fuZhuJianSelectorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fuZhuJianSelectorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__savechangeordertowc(struct soap *soap, struct ns1__savechangeordertowc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__savechangeordertowc(struct soap *soap, const struct ns1__savechangeordertowc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__savechangeordertowc(struct soap *soap, const char *tag, int id, const struct ns1__savechangeordertowc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__savechangeordertowc), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__savechangeordertowc * SOAP_FMAC4 soap_in_ns1__savechangeordertowc(struct soap *soap, const char *tag, struct ns1__savechangeordertowc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__savechangeordertowc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__savechangeordertowc, sizeof(struct ns1__savechangeordertowc), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__savechangeordertowc(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__savechangeordertowc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__savechangeordertowc, SOAP_TYPE_ns1__savechangeordertowc, sizeof(struct ns1__savechangeordertowc), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__savechangeordertowc * SOAP_FMAC2 soap_instantiate_ns1__savechangeordertowc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__savechangeordertowc(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__savechangeordertowc *p;
	size_t k = sizeof(struct ns1__savechangeordertowc);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__savechangeordertowc);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__savechangeordertowc, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__savechangeordertowc location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__savechangeordertowc, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__savechangeordertowc(struct soap *soap, const struct ns1__savechangeordertowc *a, const char *tag, const char *type)
{
	if (soap_out_ns1__savechangeordertowc(soap, tag ? tag : "ns1:savechangeordertowc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__savechangeordertowc * SOAP_FMAC4 soap_get_ns1__savechangeordertowc(struct soap *soap, struct ns1__savechangeordertowc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__savechangeordertowc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__savechangeordertowcResponse(struct soap *soap, struct ns1__savechangeordertowcResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__savechangeordertowcResponse(struct soap *soap, const struct ns1__savechangeordertowcResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__savechangeordertowcResponse(struct soap *soap, const char *tag, int id, const struct ns1__savechangeordertowcResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__savechangeordertowcResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__savechangeordertowcResponse * SOAP_FMAC4 soap_in_ns1__savechangeordertowcResponse(struct soap *soap, const char *tag, struct ns1__savechangeordertowcResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__savechangeordertowcResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__savechangeordertowcResponse, sizeof(struct ns1__savechangeordertowcResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__savechangeordertowcResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__savechangeordertowcResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__savechangeordertowcResponse, SOAP_TYPE_ns1__savechangeordertowcResponse, sizeof(struct ns1__savechangeordertowcResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__savechangeordertowcResponse * SOAP_FMAC2 soap_instantiate_ns1__savechangeordertowcResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__savechangeordertowcResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__savechangeordertowcResponse *p;
	size_t k = sizeof(struct ns1__savechangeordertowcResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__savechangeordertowcResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__savechangeordertowcResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__savechangeordertowcResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__savechangeordertowcResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__savechangeordertowcResponse(struct soap *soap, const struct ns1__savechangeordertowcResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__savechangeordertowcResponse(soap, tag ? tag : "ns1:savechangeordertowcResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__savechangeordertowcResponse * SOAP_FMAC4 soap_get_ns1__savechangeordertowcResponse(struct soap *soap, struct ns1__savechangeordertowcResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__savechangeordertowcResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPbomOriginalItemByPartNumber(struct soap *soap, struct ns1__getPbomOriginalItemByPartNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPbomOriginalItemByPartNumber(struct soap *soap, const struct ns1__getPbomOriginalItemByPartNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPbomOriginalItemByPartNumber(struct soap *soap, const char *tag, int id, const struct ns1__getPbomOriginalItemByPartNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPbomOriginalItemByPartNumber * SOAP_FMAC4 soap_in_ns1__getPbomOriginalItemByPartNumber(struct soap *soap, const char *tag, struct ns1__getPbomOriginalItemByPartNumber *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPbomOriginalItemByPartNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber, sizeof(struct ns1__getPbomOriginalItemByPartNumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getPbomOriginalItemByPartNumber(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getPbomOriginalItemByPartNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber, sizeof(struct ns1__getPbomOriginalItemByPartNumber), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getPbomOriginalItemByPartNumber * SOAP_FMAC2 soap_instantiate_ns1__getPbomOriginalItemByPartNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPbomOriginalItemByPartNumber(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getPbomOriginalItemByPartNumber *p;
	size_t k = sizeof(struct ns1__getPbomOriginalItemByPartNumber);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getPbomOriginalItemByPartNumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getPbomOriginalItemByPartNumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getPbomOriginalItemByPartNumber location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPbomOriginalItemByPartNumber(struct soap *soap, const struct ns1__getPbomOriginalItemByPartNumber *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getPbomOriginalItemByPartNumber(soap, tag ? tag : "ns1:getPbomOriginalItemByPartNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPbomOriginalItemByPartNumber * SOAP_FMAC4 soap_get_ns1__getPbomOriginalItemByPartNumber(struct soap *soap, struct ns1__getPbomOriginalItemByPartNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPbomOriginalItemByPartNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPbomOriginalItemByPartNumberResponse(struct soap *soap, struct ns1__getPbomOriginalItemByPartNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPbomOriginalItemByPartNumberResponse(struct soap *soap, const struct ns1__getPbomOriginalItemByPartNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPbomOriginalItemByPartNumberResponse(struct soap *soap, const char *tag, int id, const struct ns1__getPbomOriginalItemByPartNumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPbomOriginalItemByPartNumberResponse * SOAP_FMAC4 soap_in_ns1__getPbomOriginalItemByPartNumberResponse(struct soap *soap, const char *tag, struct ns1__getPbomOriginalItemByPartNumberResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPbomOriginalItemByPartNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse, sizeof(struct ns1__getPbomOriginalItemByPartNumberResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getPbomOriginalItemByPartNumberResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getPbomOriginalItemByPartNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse, sizeof(struct ns1__getPbomOriginalItemByPartNumberResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getPbomOriginalItemByPartNumberResponse * SOAP_FMAC2 soap_instantiate_ns1__getPbomOriginalItemByPartNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPbomOriginalItemByPartNumberResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getPbomOriginalItemByPartNumberResponse *p;
	size_t k = sizeof(struct ns1__getPbomOriginalItemByPartNumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getPbomOriginalItemByPartNumberResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getPbomOriginalItemByPartNumberResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getPbomOriginalItemByPartNumberResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getPbomOriginalItemByPartNumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPbomOriginalItemByPartNumberResponse(struct soap *soap, const struct ns1__getPbomOriginalItemByPartNumberResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getPbomOriginalItemByPartNumberResponse(soap, tag ? tag : "ns1:getPbomOriginalItemByPartNumberResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPbomOriginalItemByPartNumberResponse * SOAP_FMAC4 soap_get_ns1__getPbomOriginalItemByPartNumberResponse(struct soap *soap, struct ns1__getPbomOriginalItemByPartNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPbomOriginalItemByPartNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPbomEndPartByPartNumber(struct soap *soap, struct ns1__getPbomEndPartByPartNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPbomEndPartByPartNumber(struct soap *soap, const struct ns1__getPbomEndPartByPartNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPbomEndPartByPartNumber(struct soap *soap, const char *tag, int id, const struct ns1__getPbomEndPartByPartNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPbomEndPartByPartNumber), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPbomEndPartByPartNumber * SOAP_FMAC4 soap_in_ns1__getPbomEndPartByPartNumber(struct soap *soap, const char *tag, struct ns1__getPbomEndPartByPartNumber *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPbomEndPartByPartNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPbomEndPartByPartNumber, sizeof(struct ns1__getPbomEndPartByPartNumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getPbomEndPartByPartNumber(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getPbomEndPartByPartNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPbomEndPartByPartNumber, SOAP_TYPE_ns1__getPbomEndPartByPartNumber, sizeof(struct ns1__getPbomEndPartByPartNumber), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getPbomEndPartByPartNumber * SOAP_FMAC2 soap_instantiate_ns1__getPbomEndPartByPartNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPbomEndPartByPartNumber(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getPbomEndPartByPartNumber *p;
	size_t k = sizeof(struct ns1__getPbomEndPartByPartNumber);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getPbomEndPartByPartNumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getPbomEndPartByPartNumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getPbomEndPartByPartNumber location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getPbomEndPartByPartNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPbomEndPartByPartNumber(struct soap *soap, const struct ns1__getPbomEndPartByPartNumber *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getPbomEndPartByPartNumber(soap, tag ? tag : "ns1:getPbomEndPartByPartNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPbomEndPartByPartNumber * SOAP_FMAC4 soap_get_ns1__getPbomEndPartByPartNumber(struct soap *soap, struct ns1__getPbomEndPartByPartNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPbomEndPartByPartNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPbomEndPartByPartNumberResponse(struct soap *soap, struct ns1__getPbomEndPartByPartNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPbomEndPartByPartNumberResponse(struct soap *soap, const struct ns1__getPbomEndPartByPartNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPbomEndPartByPartNumberResponse(struct soap *soap, const char *tag, int id, const struct ns1__getPbomEndPartByPartNumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPbomEndPartByPartNumberResponse * SOAP_FMAC4 soap_in_ns1__getPbomEndPartByPartNumberResponse(struct soap *soap, const char *tag, struct ns1__getPbomEndPartByPartNumberResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPbomEndPartByPartNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse, sizeof(struct ns1__getPbomEndPartByPartNumberResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getPbomEndPartByPartNumberResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getPbomEndPartByPartNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse, SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse, sizeof(struct ns1__getPbomEndPartByPartNumberResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getPbomEndPartByPartNumberResponse * SOAP_FMAC2 soap_instantiate_ns1__getPbomEndPartByPartNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPbomEndPartByPartNumberResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getPbomEndPartByPartNumberResponse *p;
	size_t k = sizeof(struct ns1__getPbomEndPartByPartNumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getPbomEndPartByPartNumberResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getPbomEndPartByPartNumberResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getPbomEndPartByPartNumberResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getPbomEndPartByPartNumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPbomEndPartByPartNumberResponse(struct soap *soap, const struct ns1__getPbomEndPartByPartNumberResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getPbomEndPartByPartNumberResponse(soap, tag ? tag : "ns1:getPbomEndPartByPartNumberResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPbomEndPartByPartNumberResponse * SOAP_FMAC4 soap_get_ns1__getPbomEndPartByPartNumberResponse(struct soap *soap, struct ns1__getPbomEndPartByPartNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPbomEndPartByPartNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getorderbyoid(struct soap *soap, struct ns1__getorderbyoid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getorderbyoid(struct soap *soap, const struct ns1__getorderbyoid *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getorderbyoid(struct soap *soap, const char *tag, int id, const struct ns1__getorderbyoid *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getorderbyoid), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getorderbyoid * SOAP_FMAC4 soap_in_ns1__getorderbyoid(struct soap *soap, const char *tag, struct ns1__getorderbyoid *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getorderbyoid *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getorderbyoid, sizeof(struct ns1__getorderbyoid), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getorderbyoid(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getorderbyoid *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getorderbyoid, SOAP_TYPE_ns1__getorderbyoid, sizeof(struct ns1__getorderbyoid), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getorderbyoid * SOAP_FMAC2 soap_instantiate_ns1__getorderbyoid(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getorderbyoid(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getorderbyoid *p;
	size_t k = sizeof(struct ns1__getorderbyoid);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getorderbyoid);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getorderbyoid, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getorderbyoid location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getorderbyoid, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getorderbyoid(struct soap *soap, const struct ns1__getorderbyoid *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getorderbyoid(soap, tag ? tag : "ns1:getorderbyoid", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getorderbyoid * SOAP_FMAC4 soap_get_ns1__getorderbyoid(struct soap *soap, struct ns1__getorderbyoid *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getorderbyoid(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getorderbyoidResponse(struct soap *soap, struct ns1__getorderbyoidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getorderbyoidResponse(struct soap *soap, const struct ns1__getorderbyoidResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getorderbyoidResponse(struct soap *soap, const char *tag, int id, const struct ns1__getorderbyoidResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getorderbyoidResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getorderbyoidResponse * SOAP_FMAC4 soap_in_ns1__getorderbyoidResponse(struct soap *soap, const char *tag, struct ns1__getorderbyoidResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getorderbyoidResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getorderbyoidResponse, sizeof(struct ns1__getorderbyoidResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getorderbyoidResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getorderbyoidResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getorderbyoidResponse, SOAP_TYPE_ns1__getorderbyoidResponse, sizeof(struct ns1__getorderbyoidResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getorderbyoidResponse * SOAP_FMAC2 soap_instantiate_ns1__getorderbyoidResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getorderbyoidResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getorderbyoidResponse *p;
	size_t k = sizeof(struct ns1__getorderbyoidResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getorderbyoidResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getorderbyoidResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getorderbyoidResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getorderbyoidResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getorderbyoidResponse(struct soap *soap, const struct ns1__getorderbyoidResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getorderbyoidResponse(soap, tag ? tag : "ns1:getorderbyoidResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getorderbyoidResponse * SOAP_FMAC4 soap_get_ns1__getorderbyoidResponse(struct soap *soap, struct ns1__getorderbyoidResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getorderbyoidResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveordertowc(struct soap *soap, struct ns1__saveordertowc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveordertowc(struct soap *soap, const struct ns1__saveordertowc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveordertowc(struct soap *soap, const char *tag, int id, const struct ns1__saveordertowc *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveordertowc), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveordertowc * SOAP_FMAC4 soap_in_ns1__saveordertowc(struct soap *soap, const char *tag, struct ns1__saveordertowc *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveordertowc *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveordertowc, sizeof(struct ns1__saveordertowc), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveordertowc(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__saveordertowc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveordertowc, SOAP_TYPE_ns1__saveordertowc, sizeof(struct ns1__saveordertowc), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__saveordertowc * SOAP_FMAC2 soap_instantiate_ns1__saveordertowc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveordertowc(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__saveordertowc *p;
	size_t k = sizeof(struct ns1__saveordertowc);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__saveordertowc);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__saveordertowc, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__saveordertowc location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__saveordertowc, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveordertowc(struct soap *soap, const struct ns1__saveordertowc *a, const char *tag, const char *type)
{
	if (soap_out_ns1__saveordertowc(soap, tag ? tag : "ns1:saveordertowc", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveordertowc * SOAP_FMAC4 soap_get_ns1__saveordertowc(struct soap *soap, struct ns1__saveordertowc *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveordertowc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__saveordertowcResponse(struct soap *soap, struct ns1__saveordertowcResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__saveordertowcResponse(struct soap *soap, const struct ns1__saveordertowcResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__saveordertowcResponse(struct soap *soap, const char *tag, int id, const struct ns1__saveordertowcResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__saveordertowcResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__saveordertowcResponse * SOAP_FMAC4 soap_in_ns1__saveordertowcResponse(struct soap *soap, const char *tag, struct ns1__saveordertowcResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__saveordertowcResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__saveordertowcResponse, sizeof(struct ns1__saveordertowcResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__saveordertowcResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__saveordertowcResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__saveordertowcResponse, SOAP_TYPE_ns1__saveordertowcResponse, sizeof(struct ns1__saveordertowcResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__saveordertowcResponse * SOAP_FMAC2 soap_instantiate_ns1__saveordertowcResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__saveordertowcResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__saveordertowcResponse *p;
	size_t k = sizeof(struct ns1__saveordertowcResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__saveordertowcResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__saveordertowcResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__saveordertowcResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__saveordertowcResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__saveordertowcResponse(struct soap *soap, const struct ns1__saveordertowcResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__saveordertowcResponse(soap, tag ? tag : "ns1:saveordertowcResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__saveordertowcResponse * SOAP_FMAC4 soap_get_ns1__saveordertowcResponse(struct soap *soap, struct ns1__saveordertowcResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__saveordertowcResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPbomLinkByPartNumber(struct soap *soap, struct ns1__getPbomLinkByPartNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPbomLinkByPartNumber(struct soap *soap, const struct ns1__getPbomLinkByPartNumber *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPbomLinkByPartNumber(struct soap *soap, const char *tag, int id, const struct ns1__getPbomLinkByPartNumber *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPbomLinkByPartNumber), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPbomLinkByPartNumber * SOAP_FMAC4 soap_in_ns1__getPbomLinkByPartNumber(struct soap *soap, const char *tag, struct ns1__getPbomLinkByPartNumber *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPbomLinkByPartNumber *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPbomLinkByPartNumber, sizeof(struct ns1__getPbomLinkByPartNumber), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getPbomLinkByPartNumber(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getPbomLinkByPartNumber *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPbomLinkByPartNumber, SOAP_TYPE_ns1__getPbomLinkByPartNumber, sizeof(struct ns1__getPbomLinkByPartNumber), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getPbomLinkByPartNumber * SOAP_FMAC2 soap_instantiate_ns1__getPbomLinkByPartNumber(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPbomLinkByPartNumber(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getPbomLinkByPartNumber *p;
	size_t k = sizeof(struct ns1__getPbomLinkByPartNumber);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getPbomLinkByPartNumber);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getPbomLinkByPartNumber, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getPbomLinkByPartNumber location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getPbomLinkByPartNumber, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPbomLinkByPartNumber(struct soap *soap, const struct ns1__getPbomLinkByPartNumber *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getPbomLinkByPartNumber(soap, tag ? tag : "ns1:getPbomLinkByPartNumber", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPbomLinkByPartNumber * SOAP_FMAC4 soap_get_ns1__getPbomLinkByPartNumber(struct soap *soap, struct ns1__getPbomLinkByPartNumber *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPbomLinkByPartNumber(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getPbomLinkByPartNumberResponse(struct soap *soap, struct ns1__getPbomLinkByPartNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getPbomLinkByPartNumberResponse(struct soap *soap, const struct ns1__getPbomLinkByPartNumberResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPbomLinkByPartNumberResponse(struct soap *soap, const char *tag, int id, const struct ns1__getPbomLinkByPartNumberResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getPbomLinkByPartNumberResponse * SOAP_FMAC4 soap_in_ns1__getPbomLinkByPartNumberResponse(struct soap *soap, const char *tag, struct ns1__getPbomLinkByPartNumberResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getPbomLinkByPartNumberResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse, sizeof(struct ns1__getPbomLinkByPartNumberResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getPbomLinkByPartNumberResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__getPbomLinkByPartNumberResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse, SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse, sizeof(struct ns1__getPbomLinkByPartNumberResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__getPbomLinkByPartNumberResponse * SOAP_FMAC2 soap_instantiate_ns1__getPbomLinkByPartNumberResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPbomLinkByPartNumberResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__getPbomLinkByPartNumberResponse *p;
	size_t k = sizeof(struct ns1__getPbomLinkByPartNumberResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__getPbomLinkByPartNumberResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__getPbomLinkByPartNumberResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__getPbomLinkByPartNumberResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__getPbomLinkByPartNumberResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getPbomLinkByPartNumberResponse(struct soap *soap, const struct ns1__getPbomLinkByPartNumberResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__getPbomLinkByPartNumberResponse(soap, tag ? tag : "ns1:getPbomLinkByPartNumberResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__getPbomLinkByPartNumberResponse * SOAP_FMAC4 soap_get_ns1__getPbomLinkByPartNumberResponse(struct soap *soap, struct ns1__getPbomLinkByPartNumberResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPbomLinkByPartNumberResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ping(struct soap *soap, struct ns1__ping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ping(struct soap *soap, const struct ns1__ping *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ping(struct soap *soap, const char *tag, int id, const struct ns1__ping *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ping), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ping * SOAP_FMAC4 soap_in_ns1__ping(struct soap *soap, const char *tag, struct ns1__ping *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ping *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ping, sizeof(struct ns1__ping), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ping(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ping *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ping, SOAP_TYPE_ns1__ping, sizeof(struct ns1__ping), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__ping * SOAP_FMAC2 soap_instantiate_ns1__ping(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ping(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__ping *p;
	size_t k = sizeof(struct ns1__ping);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__ping);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__ping, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__ping location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ping, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ping(struct soap *soap, const struct ns1__ping *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ping(soap, tag ? tag : "ns1:ping", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ping * SOAP_FMAC4 soap_get_ns1__ping(struct soap *soap, struct ns1__ping *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ping(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__pingResponse(struct soap *soap, struct ns1__pingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__pingResponse(struct soap *soap, const struct ns1__pingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__pingResponse(struct soap *soap, const char *tag, int id, const struct ns1__pingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__pingResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__pingResponse * SOAP_FMAC4 soap_in_ns1__pingResponse(struct soap *soap, const char *tag, struct ns1__pingResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__pingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__pingResponse, sizeof(struct ns1__pingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__pingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__pingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__pingResponse, SOAP_TYPE_ns1__pingResponse, sizeof(struct ns1__pingResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__pingResponse * SOAP_FMAC2 soap_instantiate_ns1__pingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__pingResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__pingResponse *p;
	size_t k = sizeof(struct ns1__pingResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__pingResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__pingResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__pingResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__pingResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__pingResponse(struct soap *soap, const struct ns1__pingResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__pingResponse(soap, tag ? tag : "ns1:pingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__pingResponse * SOAP_FMAC4 soap_get_ns1__pingResponse(struct soap *soap, struct ns1__pingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__pingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jmsexample(struct soap *soap, struct ns1__jmsexample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->arg1);
	soap_default_string(soap, &a->arg2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jmsexample(struct soap *soap, const struct ns1__jmsexample *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->arg1);
	soap_serialize_string(soap, (char*const*)&a->arg2);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jmsexample(struct soap *soap, const char *tag, int id, const struct ns1__jmsexample *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jmsexample), type))
		return soap->error;
	if (soap_out_string(soap, "arg1", -1, (char*const*)&a->arg1, ""))
		return soap->error;
	if (soap_out_string(soap, "arg2", -1, (char*const*)&a->arg2, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jmsexample * SOAP_FMAC4 soap_in_ns1__jmsexample(struct soap *soap, const char *tag, struct ns1__jmsexample *a, const char *type)
{
	size_t soap_flag_arg1 = 1;
	size_t soap_flag_arg2 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jmsexample *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jmsexample, sizeof(struct ns1__jmsexample), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jmsexample(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "arg1", (char**)&a->arg1, "xsd:string"))
				{	soap_flag_arg1--;
					continue;
				}
			if (soap_flag_arg2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "arg2", (char**)&a->arg2, "xsd:string"))
				{	soap_flag_arg2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__jmsexample *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jmsexample, SOAP_TYPE_ns1__jmsexample, sizeof(struct ns1__jmsexample), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__jmsexample * SOAP_FMAC2 soap_instantiate_ns1__jmsexample(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jmsexample(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__jmsexample *p;
	size_t k = sizeof(struct ns1__jmsexample);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__jmsexample);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__jmsexample, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__jmsexample location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__jmsexample, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jmsexample(struct soap *soap, const struct ns1__jmsexample *a, const char *tag, const char *type)
{
	if (soap_out_ns1__jmsexample(soap, tag ? tag : "ns1:jmsexample", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jmsexample * SOAP_FMAC4 soap_get_ns1__jmsexample(struct soap *soap, struct ns1__jmsexample *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jmsexample(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__jmsexampleResponse(struct soap *soap, struct ns1__jmsexampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__jmsexampleResponse(struct soap *soap, const struct ns1__jmsexampleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__jmsexampleResponse(struct soap *soap, const char *tag, int id, const struct ns1__jmsexampleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__jmsexampleResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__jmsexampleResponse * SOAP_FMAC4 soap_in_ns1__jmsexampleResponse(struct soap *soap, const char *tag, struct ns1__jmsexampleResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__jmsexampleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__jmsexampleResponse, sizeof(struct ns1__jmsexampleResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__jmsexampleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__jmsexampleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__jmsexampleResponse, SOAP_TYPE_ns1__jmsexampleResponse, sizeof(struct ns1__jmsexampleResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__jmsexampleResponse * SOAP_FMAC2 soap_instantiate_ns1__jmsexampleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__jmsexampleResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__jmsexampleResponse *p;
	size_t k = sizeof(struct ns1__jmsexampleResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__jmsexampleResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__jmsexampleResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__jmsexampleResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__jmsexampleResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__jmsexampleResponse(struct soap *soap, const struct ns1__jmsexampleResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__jmsexampleResponse(soap, tag ? tag : "ns1:jmsexampleResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__jmsexampleResponse * SOAP_FMAC4 soap_get_ns1__jmsexampleResponse(struct soap *soap, struct ns1__jmsexampleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__jmsexampleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetWSDL(struct soap *soap, struct ns1__GetWSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetWSDL(struct soap *soap, const struct ns1__GetWSDL *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetWSDL(struct soap *soap, const char *tag, int id, const struct ns1__GetWSDL *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetWSDL), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetWSDL * SOAP_FMAC4 soap_in_ns1__GetWSDL(struct soap *soap, const char *tag, struct ns1__GetWSDL *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetWSDL *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetWSDL, sizeof(struct ns1__GetWSDL), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetWSDL(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__GetWSDL *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetWSDL, SOAP_TYPE_ns1__GetWSDL, sizeof(struct ns1__GetWSDL), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetWSDL * SOAP_FMAC2 soap_instantiate_ns1__GetWSDL(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetWSDL(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetWSDL *p;
	size_t k = sizeof(struct ns1__GetWSDL);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__GetWSDL);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__GetWSDL, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetWSDL location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__GetWSDL, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetWSDL(struct soap *soap, const struct ns1__GetWSDL *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetWSDL(soap, tag ? tag : "ns1:GetWSDL", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetWSDL * SOAP_FMAC4 soap_get_ns1__GetWSDL(struct soap *soap, struct ns1__GetWSDL *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetWSDL(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__GetWSDLResponse(struct soap *soap, struct ns1__GetWSDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__GetWSDLResponse(struct soap *soap, const struct ns1__GetWSDLResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GetWSDLResponse(struct soap *soap, const char *tag, int id, const struct ns1__GetWSDLResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GetWSDLResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__GetWSDLResponse * SOAP_FMAC4 soap_in_ns1__GetWSDLResponse(struct soap *soap, const char *tag, struct ns1__GetWSDLResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__GetWSDLResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GetWSDLResponse, sizeof(struct ns1__GetWSDLResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__GetWSDLResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__GetWSDLResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GetWSDLResponse, SOAP_TYPE_ns1__GetWSDLResponse, sizeof(struct ns1__GetWSDLResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__GetWSDLResponse * SOAP_FMAC2 soap_instantiate_ns1__GetWSDLResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GetWSDLResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__GetWSDLResponse *p;
	size_t k = sizeof(struct ns1__GetWSDLResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__GetWSDLResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__GetWSDLResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__GetWSDLResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__GetWSDLResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__GetWSDLResponse(struct soap *soap, const struct ns1__GetWSDLResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__GetWSDLResponse(soap, tag ? tag : "ns1:GetWSDLResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__GetWSDLResponse * SOAP_FMAC4 soap_get_ns1__GetWSDLResponse(struct soap *soap, struct ns1__GetWSDLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GetWSDLResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ExecuteSoapJmsRPC(struct soap *soap, struct ns1__ExecuteSoapJmsRPC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExecuteSoapJmsRPC(struct soap *soap, const struct ns1__ExecuteSoapJmsRPC *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExecuteSoapJmsRPC(struct soap *soap, const char *tag, int id, const struct ns1__ExecuteSoapJmsRPC *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExecuteSoapJmsRPC), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ExecuteSoapJmsRPC * SOAP_FMAC4 soap_in_ns1__ExecuteSoapJmsRPC(struct soap *soap, const char *tag, struct ns1__ExecuteSoapJmsRPC *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ExecuteSoapJmsRPC *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExecuteSoapJmsRPC, sizeof(struct ns1__ExecuteSoapJmsRPC), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ExecuteSoapJmsRPC(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ExecuteSoapJmsRPC *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExecuteSoapJmsRPC, SOAP_TYPE_ns1__ExecuteSoapJmsRPC, sizeof(struct ns1__ExecuteSoapJmsRPC), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__ExecuteSoapJmsRPC * SOAP_FMAC2 soap_instantiate_ns1__ExecuteSoapJmsRPC(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ExecuteSoapJmsRPC(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__ExecuteSoapJmsRPC *p;
	size_t k = sizeof(struct ns1__ExecuteSoapJmsRPC);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__ExecuteSoapJmsRPC);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__ExecuteSoapJmsRPC, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__ExecuteSoapJmsRPC location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ExecuteSoapJmsRPC, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExecuteSoapJmsRPC(struct soap *soap, const struct ns1__ExecuteSoapJmsRPC *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExecuteSoapJmsRPC(soap, tag ? tag : "ns1:ExecuteSoapJmsRPC", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ExecuteSoapJmsRPC * SOAP_FMAC4 soap_get_ns1__ExecuteSoapJmsRPC(struct soap *soap, struct ns1__ExecuteSoapJmsRPC *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExecuteSoapJmsRPC(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ExecuteSoapJmsRPCResponse(struct soap *soap, struct ns1__ExecuteSoapJmsRPCResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Collection);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ExecuteSoapJmsRPCResponse(struct soap *soap, const struct ns1__ExecuteSoapJmsRPCResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Collection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ExecuteSoapJmsRPCResponse(struct soap *soap, const char *tag, int id, const struct ns1__ExecuteSoapJmsRPCResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse), type))
		return soap->error;
	if (!a->Collection)
	{	if (soap_element_nil(soap, "Collection"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "Collection", -1, (char*const*)&a->Collection, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ExecuteSoapJmsRPCResponse * SOAP_FMAC4 soap_in_ns1__ExecuteSoapJmsRPCResponse(struct soap *soap, const char *tag, struct ns1__ExecuteSoapJmsRPCResponse *a, const char *type)
{
	size_t soap_flag_Collection = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ExecuteSoapJmsRPCResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse, sizeof(struct ns1__ExecuteSoapJmsRPCResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ExecuteSoapJmsRPCResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Collection && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Collection", (char**)&a->Collection, "xsd:string"))
				{	soap_flag_Collection--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Collection))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__ExecuteSoapJmsRPCResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse, SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse, sizeof(struct ns1__ExecuteSoapJmsRPCResponse), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct ns1__ExecuteSoapJmsRPCResponse * SOAP_FMAC2 soap_instantiate_ns1__ExecuteSoapJmsRPCResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ExecuteSoapJmsRPCResponse(%p, %d, %s, %s)\n", soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct ns1__ExecuteSoapJmsRPCResponse *p;
	size_t k = sizeof(struct ns1__ExecuteSoapJmsRPCResponse);
	if (n < 0)
	{	p = SOAP_NEW(struct ns1__ExecuteSoapJmsRPCResponse);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct ns1__ExecuteSoapJmsRPCResponse, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct ns1__ExecuteSoapJmsRPCResponse location=%p n=%d\n", p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ExecuteSoapJmsRPCResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ExecuteSoapJmsRPCResponse(struct soap *soap, const struct ns1__ExecuteSoapJmsRPCResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ExecuteSoapJmsRPCResponse(soap, tag ? tag : "ns1:ExecuteSoapJmsRPCResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ExecuteSoapJmsRPCResponse * SOAP_FMAC4 soap_get_ns1__ExecuteSoapJmsRPCResponse(struct soap *soap, struct ns1__ExecuteSoapJmsRPCResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ExecuteSoapJmsRPCResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new__QName(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default__QName(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
